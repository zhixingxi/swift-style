<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Google Swift Style Guide 中文版</title>
  <meta name="description" content="Google's Swift style guide.
">

  <link rel="stylesheet" href="./css/main.css">
  <link rel="canonical" href="http://localhost:4000/swift-style/">
  <link rel="alternate" type="application/rss+xml" title="Google Swift Style Guide 中文版" href="http://localhost:4000/swift-style/feed.xml">
</head>

<body>

  <main role="main">
    <article class="page">
  <header>
    <h1>Google Swift Style Guide 中文版</h1>
  </header>
  <!--  -->
<style>
article pre {
    overflow: visible;
}
</style>

<p><a href="http://pages.swift.gg/google-swift-style-guide-in-chinese/">中文原版</a></p>

<p>这份代码风格指南基于 Apple 优秀的 Swift 标准库代码风格，吸取了多个 Google 内部 Swift 项目的使用反馈而成。本文档会保持更新，并且已经基于本文档实现了格式化工具。</p>

<h2 id="目录">目录</h2>

<ul class="no_toc" id="markdown-toc">
  <li><a href="#目录" id="markdown-toc-目录">目录</a></li>
  <li><a href="#源文件的基础要求" id="markdown-toc-源文件的基础要求">源文件的基础要求</a>    <ul>
      <li><a href="#文件名" id="markdown-toc-文件名">文件名</a></li>
      <li><a href="#特殊转义字符" id="markdown-toc-特殊转义字符">特殊转义字符</a></li>
    </ul>
  </li>
  <li><a href="#源文件结构" id="markdown-toc-源文件结构">源文件结构</a>    <ul>
      <li><a href="#文件注释" id="markdown-toc-文件注释">文件注释</a></li>
      <li><a href="#导入语句" id="markdown-toc-导入语句">导入语句</a></li>
      <li><a href="#类型变量和函数声明" id="markdown-toc-类型变量和函数声明">类型，变量和函数声明</a></li>
      <li><a href="#声明重载" id="markdown-toc-声明重载">声明重载</a></li>
      <li><a href="#扩展" id="markdown-toc-扩展">扩展</a></li>
    </ul>
  </li>
  <li><a href="#常规格式" id="markdown-toc-常规格式">常规格式</a>    <ul>
      <li><a href="#单行字符限制" id="markdown-toc-单行字符限制">单行字符限制</a></li>
      <li><a href="#花括号" id="markdown-toc-花括号">花括号</a></li>
      <li><a href="#分号" id="markdown-toc-分号">分号</a></li>
      <li><a href="#每行一个语句" id="markdown-toc-每行一个语句">每行一个语句</a></li>
      <li><a href="#换行" id="markdown-toc-换行">换行</a>        <ul>
          <li><a href="#函数声明" id="markdown-toc-函数声明">函数声明</a></li>
          <li><a href="#类型和拓展声明" id="markdown-toc-类型和拓展声明">类型和拓展声明</a></li>
          <li><a href="#函数调用" id="markdown-toc-函数调用">函数调用</a></li>
          <li><a href="#控制流语句" id="markdown-toc-控制流语句">控制流语句</a></li>
          <li><a href="#其他表达" id="markdown-toc-其他表达">其他表达</a></li>
        </ul>
      </li>
      <li><a href="#水平空格" id="markdown-toc-水平空格">水平空格</a></li>
      <li><a href="#水平对齐" id="markdown-toc-水平对齐">水平对齐</a></li>
      <li><a href="#垂直空行" id="markdown-toc-垂直空行">垂直空行</a></li>
      <li><a href="#括号" id="markdown-toc-括号">括号</a></li>
    </ul>
  </li>
  <li><a href="#特定结构格式化" id="markdown-toc-特定结构格式化">特定结构格式化</a>    <ul>
      <li><a href="#非文档注释" id="markdown-toc-非文档注释">非文档注释</a></li>
      <li><a href="#属性" id="markdown-toc-属性">属性</a></li>
      <li><a href="#switch-语句" id="markdown-toc-switch-语句">Switch 语句</a></li>
      <li><a href="#枚举项" id="markdown-toc-枚举项">枚举项</a></li>
      <li><a href="#尾随闭包" id="markdown-toc-尾随闭包">尾随闭包</a></li>
      <li><a href="#末尾逗号" id="markdown-toc-末尾逗号">末尾逗号</a></li>
      <li><a href="#数字字面量" id="markdown-toc-数字字面量">数字字面量</a></li>
      <li><a href="#注解" id="markdown-toc-注解">注解</a></li>
    </ul>
  </li>
  <li><a href="#命名" id="markdown-toc-命名">命名</a>    <ul>
      <li><a href="#apple-api-代码风格指南" id="markdown-toc-apple-api-代码风格指南">Apple API 代码风格指南</a></li>
      <li><a href="#命名约定不是访问控制" id="markdown-toc-命名约定不是访问控制">命名约定不是访问控制</a></li>
      <li><a href="#标识符" id="markdown-toc-标识符">标识符</a></li>
      <li><a href="#构造器" id="markdown-toc-构造器">构造器</a></li>
      <li><a href="#静态属性和类属性" id="markdown-toc-静态属性和类属性">静态属性和类属性</a></li>
      <li><a href="#全局常量" id="markdown-toc-全局常量">全局常量</a></li>
      <li><a href="#代理方法" id="markdown-toc-代理方法">代理方法</a></li>
    </ul>
  </li>
  <li><a href="#编程实践" id="markdown-toc-编程实践">编程实践</a>    <ul>
      <li><a href="#编译器警告" id="markdown-toc-编译器警告">编译器警告</a></li>
      <li><a href="#构造器-1" id="markdown-toc-构造器-1">构造器</a></li>
      <li><a href="#属性-1" id="markdown-toc-属性-1">属性</a></li>
      <li><a href="#类型简称" id="markdown-toc-类型简称">类型简称</a></li>
      <li><a href="#可选类型" id="markdown-toc-可选类型">可选类型</a></li>
      <li><a href="#错误" id="markdown-toc-错误">错误</a></li>
      <li><a href="#强制解包和强制类型转换" id="markdown-toc-强制解包和强制类型转换">强制解包和强制类型转换</a></li>
      <li><a href="#可选值隐式解包" id="markdown-toc-可选值隐式解包">可选值隐式解包</a></li>
      <li><a href="#访问等级" id="markdown-toc-访问等级">访问等级</a></li>
      <li><a href="#嵌套和命名空间" id="markdown-toc-嵌套和命名空间">嵌套和命名空间</a></li>
      <li><a href="#提前退出的-guard" id="markdown-toc-提前退出的-guard">提前退出的 <code class="language-plaintext highlighter-rouge">guard</code></a></li>
      <li><a href="#for-where-循环" id="markdown-toc-for-where-循环"><code class="language-plaintext highlighter-rouge">for</code>-<code class="language-plaintext highlighter-rouge">where</code> 循环</a></li>
      <li><a href="#在-switch-语句里的-fallthrough" id="markdown-toc-在-switch-语句里的-fallthrough">在 <code class="language-plaintext highlighter-rouge">switch</code> 语句里的 <code class="language-plaintext highlighter-rouge">fallthrough</code></a></li>
      <li><a href="#模式匹配" id="markdown-toc-模式匹配">模式匹配</a></li>
      <li><a href="#元组模式" id="markdown-toc-元组模式">元组模式</a></li>
      <li><a href="#数字和字符串字面量" id="markdown-toc-数字和字符串字面量">数字和字符串字面量</a></li>
      <li><a href="#playground-字面量" id="markdown-toc-playground-字面量">Playground 字面量</a></li>
      <li><a href="#捕获-vs-溢出" id="markdown-toc-捕获-vs-溢出">捕获 vs 溢出</a></li>
      <li><a href="#定义新运算符" id="markdown-toc-定义新运算符">定义新运算符</a></li>
      <li><a href="#重载现有运算符" id="markdown-toc-重载现有运算符">重载现有运算符</a></li>
    </ul>
  </li>
  <li><a href="#文档注释" id="markdown-toc-文档注释">文档注释</a>    <ul>
      <li><a href="#通常格式" id="markdown-toc-通常格式">通常格式</a></li>
      <li><a href="#一句话概括" id="markdown-toc-一句话概括">一句话概括</a></li>
      <li><a href="#形参返回值和抛出标签" id="markdown-toc-形参返回值和抛出标签">形参，返回值和抛出标签</a></li>
      <li><a href="#apple-标记格式" id="markdown-toc-apple-标记格式">Apple 标记格式</a></li>
      <li><a href="#注释的位置" id="markdown-toc-注释的位置">注释的位置</a></li>
    </ul>
  </li>
</ul>
<h2 id="源文件的基础要求">源文件的基础要求</h2>

<h3 id="文件名">文件名</h3>

<p>所有 Swift 源文件以扩展名 <code class="language-plaintext highlighter-rouge">.swift</code> 结尾。</p>

<p>通常来说，源文件的名字最好描述包含的主要内容。如果文件主要包含单个类型，则用类型名命名文件。如果文件是为已存在类型添加新的协议遵循，则命名为类名和协议名的组合，通过加号（+）连接。对于更复杂的情况，最好由你自己判断。</p>

<p>例如，</p>

<ul>
  <li>文件中包含单个类型 <code class="language-plaintext highlighter-rouge">MyType</code>，命名为 <code class="language-plaintext highlighter-rouge">MyType.swift</code>。</li>
  <li>文件中包含类型 <code class="language-plaintext highlighter-rouge">MyType</code> 和一些顶层的工具函数，也命名为 <code class="language-plaintext highlighter-rouge">MyType.swift</code>。（顶层的工具函数不是主要的内容。）</li>
  <li>文件中包含单个扩展，为类型 <code class="language-plaintext highlighter-rouge">MyType</code> 添加 <code class="language-plaintext highlighter-rouge">MyProtocol</code> 协议遵循，命名为 <code class="language-plaintext highlighter-rouge">MyType+MyProtocol.swift</code>。</li>
  <li>文件中包含多个扩展，为类型 <code class="language-plaintext highlighter-rouge">MyType</code> 添加协议遵循、嵌套类型或者其他功能的拓展，可以使用更通用的命名，只要它的前缀是 <code class="language-plaintext highlighter-rouge">MyType+</code>；例如，<code class="language-plaintext highlighter-rouge">MyType+Additions.swift</code>。</li>
  <li>文件中包含多个在公共类型或命名空间下没有作用域限制的相关声明（比如一系列全局的数学函数），可以命名得更有描述性。例如：<code class="language-plaintext highlighter-rouge">Math.swift</code>。</li>
</ul>

<h3 id="特殊转义字符">特殊转义字符</h3>

<p>任何字符中如果包含了特殊转义字符（<code class="language-plaintext highlighter-rouge">\t</code>、<code class="language-plaintext highlighter-rouge">\n</code>、<code class="language-plaintext highlighter-rouge">\r</code>、<code class="language-plaintext highlighter-rouge">\"</code>、<code class="language-plaintext highlighter-rouge">\'</code>、<code class="language-plaintext highlighter-rouge">\\</code> 和 <code class="language-plaintext highlighter-rouge">\0</code>），直接使用该转义字符，不用其等价的 Unicode 转义字符（例如：<code class="language-plaintext highlighter-rouge">\u{000a}</code>）。</p>



<h2 id="源文件结构">源文件结构</h2>

<h3 id="文件注释">文件注释</h3>

<p>描述源文件内容的注释是可选的。对只包含了单一抽象（例如一个类的声明）的文件并不建议用这种注释——这种情况下，抽象本身的文档注释就足够了，文件注释只有当提供了额外的有用信息时才需要。如果文件中包含多个抽象，可以添加文件注释，对整体内容进行解释。</p>

<h3 id="导入语句">导入语句</h3>

<p>源文件中应该显式导入需要的顶层模块；不要多也不要少。如果源文件中同时使用了 <code class="language-plaintext highlighter-rouge">UIKit</code> 中的定义和 <code class="language-plaintext highlighter-rouge">Foundation</code> 中的定义，那么都进行显式导入；即使有些 Apple 框架已经在实现细节中导入其他框架。</p>

<p>优先考虑导入整个模块，而非导入单个声明或者子模块。</p>

<blockquote>
  <p>避免导入单个成员的原因如下：</p>

  <ul>
    <li>没有自动化工具来解决/组织那些导入。</li>
    <li>现存地自动化工具（例如 Xcode 迁移器）很可能无法处理导入单个成员的代码，因为这不是常见用法。</li>
    <li>目前流行的 Swift 代码风格（基于官方例子和社区代码）都是导入整个模块。</li>
  </ul>
</blockquote>

<p>如果导入完整模块的顶层定义（例如 C 接口）会污染全局命名空间，那导入单个声明是允许的。在这些情况下，由你自己判断应该如何导入。</p>

<p>如果子模块的导出功能在只导入顶层模块时不可用，那么允许导入子模块。例如：<code class="language-plaintext highlighter-rouge">UIKit.UIGestureRecognizerSubclass</code> 必须要显式导入，以暴露继承 <code class="language-plaintext highlighter-rouge">UIGestureRecognizer</code> 时代码允许重写的方法——这在只导入 <code class="language-plaintext highlighter-rouge">UIKit</code> 时并不可见。</p>

<p>导入语句不可换行。</p>

<p>在源文件中，导入语句放在除了注释以外的最前面。按以下方式分组，每组中的导入按照字母顺序排序，每组之间只有一个空行：</p>

<ol>
  <li>
    <p>无测试模块/子模块的导入</p>
  </li>
  <li>
    <p>单个声明的导入 (<code class="language-plaintext highlighter-rouge">class</code>、<code class="language-plaintext highlighter-rouge">enum</code>、<code class="language-plaintext highlighter-rouge">func</code>、<code class="language-plaintext highlighter-rouge">struct</code>、<code class="language-plaintext highlighter-rouge">var</code>)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">@testable</code> 模块的导入（只存在测试源码中）</p>
  </li>
</ol>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">CoreLocation</span>
<span class="kd">import</span> <span class="kt">MyThirdPartyModule</span>
<span class="kd">import</span> <span class="kt">SpriteKit</span>
<span class="kd">import</span> <span class="kt">UIKit</span>

<span class="kd">import</span> <span class="kd">func</span> <span class="kt">Darwin</span><span class="o">.</span><span class="kt">C</span><span class="o">.</span><span class="n">isatty</span>

<span class="kd">@testable</span> <span class="kd">import</span> <span class="kt">MyModuleUnderTest</span>
</code></pre></div></div>

<h3 id="类型变量和函数声明">类型，变量和函数声明</h3>

<p>通常情况下，大部分源文件只包含一个顶层类型，特别是类型声明很庞大时。除非在同一文件里包含多个相关类型是有意义的。例如，</p>

<ul>
  <li>
    <p>类和它的代理协议可以定义在同一文件中。</p>
  </li>
  <li>
    <p>类型和它相关的轻量帮助类型可以定义在同一文件中。这种时候 <code class="language-plaintext highlighter-rouge">fileprivate</code> 很有用，可以将类型和/或它帮助类的某些功能限制在那个文件中而非暴露给模块的其他地方。</p>
  </li>
</ul>

<p>在源文件中类型、变量和函数之间的顺序，和该类型成员的顺序，都会大大影响可读性。然而，如何组织它们并没有单一正确的法则；不同的文件和不同的类型可以用不同的方式组织它们内容的排序。</p>

<p>重要的是，每一个文件和类型使用<strong><em>同一</em></strong><em>排序逻辑</em> ，并且维护者应该可以解释清楚这个逻辑。例如，新的方法不能习惯性地加在类型的最后面，因为这只是顺从“日期递增地时间排序”，而不是有逻辑性的排序。</p>

<p>当决定成员的排序逻辑后，使用 <code class="language-plaintext highlighter-rouge">// MARK:</code> 注释对该分组提供描述，对阅读者和将来的编码者（包括你自己）是很有帮助的。这种注释也会被 Xcode 理解并在源码窗口的导航栏中提供书签。（类似的还有 <code class="language-plaintext highlighter-rouge">// MARK: -</code>，在描述之前使用一个连字符的话， Xcode 会在菜单元素前插入一条分隔线。）例如，</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">MovieRatingViewController</span><span class="p">:</span> <span class="kt">UITableViewController</span> <span class="p">{</span>

  <span class="c1">// MARK: - View controller lifecycle methods</span>

  <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewWillAppear</span><span class="p">(</span><span class="n">_</span> <span class="nv">animated</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="c1">// MARK: - Movie rating manipulation methods</span>

  <span class="kd">@objc</span> <span class="kd">private</span> <span class="kd">func</span> <span class="nf">ratingStarWasTapped</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UIButton</span><span class="p">?)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="kd">@objc</span> <span class="kd">private</span> <span class="kd">func</span> <span class="nf">criticReviewWasTapped</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UIButton</span><span class="p">?)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="声明重载">声明重载</h3>

<p>当一个类型有多个构造器或者下标，或者一个文件/类型内有多个相同名字的函数（尽管可能有不同的实参标签），<em>并且</em>当这些重载在同一类型或者扩展作用域内时，它们应该按顺序排列，不应该在中间插入其他代码。</p>

<h3 id="扩展">扩展</h3>

<p>扩展可以将一个类型的功能组织到多个“单元”中。配合成员排序和所选择的组织结构/分组，会对代码可读性有很大的帮助；你必须使用<strong><em>某种</em></strong>能给审查者解释的<em>逻辑结构</em>进行组织。</p>

<h2 id="常规格式">常规格式</h2>

<h3 id="单行字符限制">单行字符限制</h3>

<p>Swift 代码有 100 字符单行限制。除了下面的说明之外，任何超过该限制的行都需要换行，详情见 <a href="#line-wrapping">换行</a>。</p>

<p><strong>例外：</strong></p>

<ol>
  <li>
    <p>即便是遵循单行字符限制的行，也不应该破坏文本中有意义的部分（例如，注释里的长 URL ）。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">import</code> 语句。</p>
  </li>
  <li>
    <p>其他工具生成的代码。</p>
  </li>
</ol>

<h3 id="花括号">花括号</h3>

<p>通常来说，内容非空的花括号遵循 Kernighan 和 Ritchie（K&amp;R）代码风格，除了 Swift 特殊结构和规则以外：</p>

<ul>
  <li>
    <p>左花括号（<code class="language-plaintext highlighter-rouge">{</code>）之前<strong>不需要</strong>换行，<strong>除非</strong>是为了满足 <a href="#line-wrapping">换行</a> 规则。</p>
  </li>
  <li>
    <p>左花括号（<code class="language-plaintext highlighter-rouge">{</code>）之后<strong>需要</strong>换行，除非满足下面的条件</p>

    <ul>
      <li>
        <p>在闭包中，如果长度足够，将闭包的签名和花括号在同一行，在 <code class="language-plaintext highlighter-rouge">in</code> 关键字后面换行。</p>
      </li>
      <li>
        <p>可以省略成 <a href="#one-statement-per-line">单行语句</a>。</p>
      </li>
      <li>
        <p>空白块应该写作 <code class="language-plaintext highlighter-rouge">{}</code>。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>右花括号（<code class="language-plaintext highlighter-rouge">}</code>）之前<strong>需要</strong>换行，除非可以省略成 <a href="#one-statement-per-line">单行语句</a> 或是空白块。</p>
  </li>
  <li>
    <p>右花括号（<code class="language-plaintext highlighter-rouge">}</code>）之后<strong>需要</strong>换行的情况，<strong>有且仅当</strong>该花括号用作终止语句或者作为声明体。例如，<code class="language-plaintext highlighter-rouge">else</code> 块写成 <code class="language-plaintext highlighter-rouge">} else {</code> 时两个花括号在同一行。</p>
  </li>
</ul>

<h3 id="分号">分号</h3>

<p>分号（<code class="language-plaintext highlighter-rouge">;</code>）<strong>禁止使用</strong>，无论是用于终止或者分割语句。</p>

<p>换而言之，分号只可能出现在字符串字面量或者注释中。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">printSum</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">printSum</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="每行一个语句">每行一个语句</h3>

<p>每行<strong>最多</strong>一个语句，每个语句后换行，除非该行结尾的块中只有 0 或者 1 条语句。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">guard</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="n">value</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>

<span class="k">defer</span> <span class="p">{</span> <span class="n">file</span><span class="o">.</span><span class="nf">close</span><span class="p">()</span> <span class="p">}</span>

<span class="k">switch</span> <span class="n">someEnum</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">first</span><span class="p">:</span> <span class="k">return</span> <span class="mi">5</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">second</span><span class="p">:</span> <span class="k">return</span> <span class="mi">10</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">third</span><span class="p">:</span> <span class="k">return</span> <span class="mi">20</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">squares</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="p">}</span>

<span class="k">var</span> <span class="nv">someProperty</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">otherObject</span><span class="o">.</span><span class="n">property</span> <span class="p">}</span>
  <span class="k">set</span> <span class="p">{</span> <span class="n">otherObject</span><span class="o">.</span><span class="n">property</span> <span class="o">=</span> <span class="n">newValue</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">someProperty</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">otherObject</span><span class="o">.</span><span class="nf">somethingElse</span><span class="p">()</span> <span class="p">}</span>

<span class="kd">required</span> <span class="nf">init</span><span class="p">?(</span><span class="n">coder</span> <span class="nv">aDecoder</span><span class="p">:</span> <span class="kt">NSCoder</span><span class="p">)</span> <span class="p">{</span> <span class="nf">fatalError</span><span class="p">(</span><span class="s">"no coder"</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>将块里包含的单个语句和块放在同一行总是允许的。由你自己判断是否将条件语句和它的执行体放在同一行中。例如，单行条件适合跟提前返回并进行简单收尾的代码放在一行，但是当执行体里包含了函数调用或者重要的逻辑就不太合适。如果不确定哪种更好，使用多行语句。</p>

<h3 id="换行">换行</h3>

<blockquote>
  <p>术语说明：<strong>换行</strong>是将代码分割到多个行的行为，否则它们都会堆积到同一行。</p>
</blockquote>

<p>根据 Google Swift 代码风格的思想，大多声明（例如类型声明和函数声明）和其他表达式（例如函数调用）可以被划分成<strong>可破坏</strong>单元，被定义的<strong>不可破坏</strong>标记符进行分割。</p>

<p>举个例子，考虑下面这个复杂的函数声明该如何进行换行：</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">func</span> <span class="n">index</span><span class="o">&lt;</span><span class="kt">Elements</span><span class="p">:</span> <span class="kt">Collection</span><span class="p">,</span> <span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span><span class="n">of</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span> <span class="k">in</span> <span class="nv">collection</span><span class="p">:</span> <span class="kt">Elements</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Elements</span><span class="o">.</span><span class="kt">Index</span><span class="p">?</span> <span class="k">where</span> <span class="kt">Elements</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Element</span><span class="p">,</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个声明可以像下面这样进行分割（要看完整例子可能需要水平滑动）。不可破坏标记符标记为橙色；可破坏符号标记为蓝色。</p>

<pre class="lw-container lw-container-numbered"><span class="lw-ub">public func index&lt;</span><span class="lw-br">Elements: Collection, Element</span><span class="lw-ub">&gt;(</span><span class="lw-br">of element: Element, in collection: Elements</span><span class="lw-ub">) -&gt;</span><span class="lw-br">Elements.Index?</span><span class="lw-ub">where</span><span class="lw-br">Elements.Element == Element, Element: Equatable</span>{
  // ...
}
</pre>

<ol>
  <li>
    <p><strong>不可破坏</strong>标记符从开始直到标志范型实参列表开始的左尖括号（<code class="language-plaintext highlighter-rouge">&lt;</code>）。</p>
  </li>
  <li>
    <p>范型实参的<strong>可破坏</strong>列表。</p>
  </li>
  <li>
    <p><strong>不可破坏</strong>标记符（<code class="language-plaintext highlighter-rouge">&gt;（</code>）将范型实参和正式实参进行分割。</p>
  </li>
  <li>
    <p>正式实参的<strong>可破坏</strong>逗号分隔列表。</p>
  </li>
  <li>
    <p><strong>不可破坏</strong>标记符从右括号（<code class="language-plaintext highlighter-rouge">)</code>）到返回类型之前的箭头（<code class="language-plaintext highlighter-rouge">-&gt;</code>）。</p>
  </li>
  <li>
    <p><strong>可破坏</strong>返回类型。</p>
  </li>
  <li>
    <p>在范型约束列表开始的<strong>不可破坏</strong> <code class="language-plaintext highlighter-rouge">where</code> 关键字。</p>
  </li>
  <li>
    <p>范型约束的<strong>可破坏</strong>逗号分隔列表。</p>
  </li>
</ol>

<p>用上这些概念，Google Swift 代码风格的基本换行规则如下：</p>

<ol>
  <li>
    <p>如果整个声明，语句或者表达式适合使用一行，就使用一行。</p>
  </li>
  <li>
    <p>逗号分隔列表只能一个方向展示：水平或者垂直。换句话说，所有元素必须在同一行上，或者每个元素必须在单独的行上。水平向的列表不包含任何换行，即使在第一个元素之前或者最后一个元素之后。除控制流语句外，垂直向的列表在第一个元素之前和每个元素之后需要换行。</p>
  </li>
  <li>
    <p>以不可破坏标记符开始的后续行和原始行缩进保持一致。</p>
  </li>
  <li>
    <p>作为垂直向逗号分隔列表一部分的后续行在原始行缩进的基础上 +2。</p>
  </li>
  <li>
    <p>在换行的声明或者表达式后的左花括号（<code class="language-plaintext highlighter-rouge">{</code>），都和最后的后续行在同一行，除非该行的缩进是在原始行的基础上 +2。如果是后者，花括号另起一行，避免该行和之后块里的内容在视觉上有混淆。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">func</span> <span class="n">index</span><span class="o">&lt;</span><span class="kt">Elements</span><span class="p">:</span> <span class="kt">Collection</span><span class="p">,</span> <span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">of</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span>
 <span class="k">in</span> <span class="nv">collection</span><span class="p">:</span> <span class="kt">Elements</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Elements</span><span class="o">.</span><span class="kt">Index</span><span class="p">?</span>
<span class="k">where</span>
  <span class="kt">Elements</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Element</span><span class="p">,</span>
  <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span>
<span class="p">{</span>  <span class="c1">// 推荐</span>
  <span class="k">for</span> <span class="n">current</span> <span class="k">in</span> <span class="n">elements</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">func</span> <span class="n">index</span><span class="o">&lt;</span><span class="kt">Elements</span><span class="p">:</span> <span class="kt">Collection</span><span class="p">,</span> <span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">of</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span>
  <span class="k">in</span> <span class="nv">collection</span><span class="p">:</span> <span class="kt">Elements</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Elements</span><span class="o">.</span><span class="kt">Index</span><span class="p">?</span>
<span class="k">where</span>
  <span class="kt">Elements</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Element</span><span class="p">,</span>
  <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>  <span class="c1">// 不推荐</span>
  <span class="k">for</span> <span class="n">current</span> <span class="k">in</span> <span class="n">elements</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>当声明里包含了用于范型约束的 <code class="language-plaintext highlighter-rouge">where</code> 关键字时，需要遵循的额外规则：</p>

<ol>
  <li>
    <p>如果范型约束列表和返回类型在同一行时超过了单行字符限制，在 <code class="language-plaintext highlighter-rouge">where</code> 关键字<strong>之前</strong>插入换行，并且和原始行缩进保持一致。</p>
  </li>
  <li>
    <p>如果范型约束列表在换行之后依旧超过单行字符限制，那么在 <code class="language-plaintext highlighter-rouge">where</code> 关键字后换行，约束列表用垂直方向展示，并在最后一个约束后面换行。</p>
  </li>
</ol>

<p>具体例子见下面相关段落的内容。</p>

<p>这个换行风格能确保，通过缩进和换行，<em>读者</em>可以<em>快速容易地识别</em>声明的不同部分，并且在文件中的这些部分缩进风格应该保持一致。具体来说，这能避免实参基于左括号缩进而出现的锯齿效应，这在其他语言里很常见：</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">func</span> <span class="n">index</span><span class="o">&lt;</span><span class="kt">Elements</span><span class="p">:</span> <span class="kt">Collection</span><span class="p">,</span> <span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span><span class="n">of</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span>  <span class="c1">// 不推荐</span>
                                                 <span class="k">in</span> <span class="nv">collection</span><span class="p">:</span> <span class="kt">Elements</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Elements</span><span class="o">.</span><span class="kt">Index</span><span class="p">?</span>
    <span class="k">where</span> <span class="kt">Elements</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Element</span><span class="p">,</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="函数声明">函数声明</h4>

<pre class="lw-container"><span class="lw-ub"><em>modifiers</em> func <em>name</em>(</span><span class="lw-br"><em>formal arguments</em></span><span class="lw-ub">)</span>{
<span class="lw-ub"><em>modifiers</em> func <em>name</em>(</span><span class="lw-br"><em>formal arguments</em></span><span class="lw-ub">) -&gt;</span><span class="lw-br"><em>result</em></span>{

<span class="lw-ub"><em>modifiers</em> func <em>name</em>&lt;</span><span class="lw-br"><em>generic arguments</em></span><span class="lw-ub">&gt;(</span><span class="lw-br"><em>formal arguments</em></span><span class="lw-ub">) throws -&gt;</span><span class="lw-br"><em>result</em></span>{

<span class="lw-ub"><em>modifiers</em> func <em>name</em>&lt;</span><span class="lw-br"><em>generic arguments</em></span><span class="lw-ub">&gt;(</span><span class="lw-br"><em>formal arguments</em></span><span class="lw-ub">) throws -&gt;</span><span class="lw-br"><em>result</em></span><span class="lw-ub">where</span><span class="lw-br"><em>generic constraints</em></span>{
</pre>

<p>将上面的规则从左到右应用得到下面的换行：</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">func</span> <span class="n">index</span><span class="o">&lt;</span><span class="kt">Elements</span><span class="p">:</span> <span class="kt">Collection</span><span class="p">,</span> <span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">of</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span>
  <span class="k">in</span> <span class="nv">collection</span><span class="p">:</span> <span class="kt">Elements</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Elements</span><span class="o">.</span><span class="kt">Index</span><span class="p">?</span> <span class="k">where</span> <span class="kt">Elements</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Element</span><span class="p">,</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">current</span> <span class="k">in</span> <span class="n">elements</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>协议里以右括号（<code class="language-plaintext highlighter-rouge">)</code>）结束的函数声明可以将括号和最后的实参放在同一行<strong>或者</strong>另起一行。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">ContrivedExampleDelegate</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">contrivedExample</span><span class="p">(</span>
    <span class="n">_</span> <span class="nv">contrivedExample</span><span class="p">:</span> <span class="kt">ContrivedExample</span><span class="p">,</span>
    <span class="n">willDoSomethingTo</span> <span class="nv">someValue</span><span class="p">:</span> <span class="kt">SomeValue</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">ContrivedExampleDelegate</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">contrivedExample</span><span class="p">(</span>
    <span class="n">_</span> <span class="nv">contrivedExample</span><span class="p">:</span> <span class="kt">ContrivedExample</span><span class="p">,</span>
    <span class="n">willDoSomethingTo</span> <span class="nv">someValue</span><span class="p">:</span> <span class="kt">SomeValue</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果类型很复杂和/或有深层嵌套，在作为实参/约束列表和/或返回类型的单个元素时也可能需要换行。在这种罕见情况下，使用和声明一致的换行规则。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">func</span> <span class="n">performanceTrackingIndex</span><span class="o">&lt;</span><span class="kt">Elements</span><span class="p">:</span> <span class="kt">Collection</span><span class="p">,</span> <span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">of</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span>
  <span class="k">in</span> <span class="nv">collection</span><span class="p">:</span> <span class="kt">Elements</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span>
  <span class="kt">Element</span><span class="o">.</span><span class="kt">Index</span><span class="p">?,</span>
  <span class="kt">PerformanceTrackingIndexStatistics</span><span class="o">.</span><span class="kt">Timings</span><span class="p">,</span>
  <span class="kt">PerformanceTrackingIndexStatistics</span><span class="o">.</span><span class="kt">SpaceUsed</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>然而，用 <code class="language-plaintext highlighter-rouge">typealias</code> 或其他手段简化复杂声明通常是更好的解决方法。</p>

<h4 id="类型和拓展声明">类型和拓展声明</h4>

<p>下面的例子同样适用于 <code class="language-plaintext highlighter-rouge">class</code>、<code class="language-plaintext highlighter-rouge">struct</code>、<code class="language-plaintext highlighter-rouge">enum</code>、<code class="language-plaintext highlighter-rouge">extension</code> 和 <code class="language-plaintext highlighter-rouge">protocol</code>（除了第一个的继承列表里有父类外，其余结构都是类似的）。</p>

<pre class="lw-container"><span class="lw-ub"><em>modifiers</em> class <em>Name</em></span>{

<span class="lw-ub"><em>modifiers</em> class <em>Name</em>:</span><span class="lw-br"><em>superclass and protocols</em></span>{

<span class="lw-ub"><em>modifiers</em> class <em>Name</em>&lt;</span><span class="lw-br"><em>generic arguments</em></span><span class="lw-ub">&gt;:</span><span class="lw-br"><em>superclass and protocols</em></span>{

<span class="lw-ub"><em>modifiers</em> class <em>Name</em>&lt;</span><span class="lw-br"><em>generic arguments</em></span><span class="lw-ub">&gt;:</span><span class="lw-br"><em>superclass and protocols</em></span><span class="lw-ub">where</span><span class="lw-br"><em>generic constraints</em></span>{
</pre>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">MyClass</span><span class="p">:</span>
  <span class="kt">MySuperclass</span><span class="p">,</span>
  <span class="kt">MyProtocol</span><span class="p">,</span>
  <span class="kt">SomeoneElsesProtocol</span><span class="p">,</span>
  <span class="kt">SomeFrameworkProtocol</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">MyContainer</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span><span class="p">:</span>
  <span class="kt">MyContainerSuperclass</span><span class="p">,</span>
  <span class="kt">MyContainerProtocol</span><span class="p">,</span>
  <span class="kt">SomeoneElsesContainerProtocol</span><span class="p">,</span>
  <span class="kt">SomeFrameworkContainerProtocol</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">MyContainer</span><span class="o">&lt;</span><span class="kt">BaseCollection</span><span class="o">&gt;</span><span class="p">:</span>
  <span class="kt">MyContainerSuperclass</span><span class="p">,</span>
  <span class="kt">MyContainerProtocol</span><span class="p">,</span>
  <span class="kt">SomeoneElsesContainerProtocol</span><span class="p">,</span>
  <span class="kt">SomeFrameworkContainerProtocol</span>
<span class="k">where</span> <span class="kt">BaseCollection</span><span class="p">:</span> <span class="kt">Collection</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">MyContainer</span><span class="o">&lt;</span><span class="kt">BaseCollection</span><span class="o">&gt;</span><span class="p">:</span>
  <span class="kt">MyContainerSuperclass</span><span class="p">,</span>
  <span class="kt">MyContainerProtocol</span><span class="p">,</span>
  <span class="kt">SomeoneElsesContainerProtocol</span><span class="p">,</span>
  <span class="kt">SomeFrameworkContainerProtocol</span>
<span class="k">where</span>
  <span class="kt">BaseCollection</span><span class="p">:</span> <span class="kt">Collection</span><span class="p">,</span>
  <span class="kt">BaseCollection</span><span class="o">.</span><span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span><span class="p">,</span>
  <span class="kt">BaseCollection</span><span class="o">.</span><span class="kt">Element</span><span class="p">:</span> <span class="kt">SomeOtherProtocolOnlyUsedToForceLineWrapping</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="函数调用">函数调用</h4>

<p>当函数调用需要换行时，每一个实参单独一行，并在原始行缩进基础上 +2。</p>

<p>和函数声明一样，如果函数调用的语句以右括号（<code class="language-plaintext highlighter-rouge">)</code>）结束（意味着没有尾随闭包），括号<strong>既可以</strong>和最后一个实参在同一行<strong>也可以</strong>另起一行。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="nf">index</span><span class="p">(</span>
  <span class="nv">of</span><span class="p">:</span> <span class="n">veryLongElementVariableName</span><span class="p">,</span>
  <span class="nv">in</span><span class="p">:</span> <span class="n">aCollectionOfElementsThatAlsoHappensToHaveALongName</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="nf">index</span><span class="p">(</span>
  <span class="nv">of</span><span class="p">:</span> <span class="n">veryLongElementVariableName</span><span class="p">,</span>
  <span class="nv">in</span><span class="p">:</span> <span class="n">aCollectionOfElementsThatAlsoHappensToHaveALongName</span>
<span class="p">)</span>
</code></pre></div></div>

<p>如果函数调用以尾随闭包结束，并且闭包签名需要换行的话，另起一行并将实参列表包在括号中以便和下面的闭包体区分。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">someAsynchronousAction</span><span class="o">.</span><span class="nf">execute</span><span class="p">(</span><span class="nv">withDelay</span><span class="p">:</span> <span class="n">howManySeconds</span><span class="p">,</span> <span class="nv">context</span><span class="p">:</span> <span class="n">actionContext</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">completion</span><span class="p">)</span> <span class="k">in</span>
  <span class="nf">doSomething</span><span class="p">(</span><span class="nv">withContext</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span>
  <span class="nf">completion</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="控制流语句">控制流语句</h4>

<p>当控制流语句（例如 <code class="language-plaintext highlighter-rouge">if</code>、<code class="language-plaintext highlighter-rouge">gurad</code>、<code class="language-plaintext highlighter-rouge">while</code> 或者 <code class="language-plaintext highlighter-rouge">for</code>）需要换行时，首个后续行的缩进和紧接着控制流关键字的元素保持一致。其余的后续行如果是语法上平级的元素，那么缩进也保持一致，如果语法上有嵌套层级，则在原来缩进基础上 +2。</p>

<p>控制流语句执行体前面的左花括号（<code class="language-plaintext highlighter-rouge">{</code>），既可以和最后的条件同一行，也可以另起一行并和该语句缩进保持一致。对于 <code class="language-plaintext highlighter-rouge">guard</code> 语句，<code class="language-plaintext highlighter-rouge">else {</code> 必须连在一起，不管是在同一行还是另起一行。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="nf">aBooleanValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
   <span class="nf">aDifferentBooleanValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
   <span class="nf">yetAnotherBooleanValueThatContributesToTheWrapping</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nf">aBooleanValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
   <span class="nf">aDifferentBooleanValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
   <span class="nf">yetAnotherBooleanValueThatContributesToTheWrapping</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">if</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="nf">aValueReturnedByAVeryLongOptionalThing</span><span class="p">(),</span>
   <span class="k">let</span> <span class="nv">value2</span> <span class="o">=</span> <span class="nf">aDifferentValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">if</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="nf">aValueReturnedByAVeryLongOptionalThing</span><span class="p">(),</span>
   <span class="k">let</span> <span class="nv">value2</span> <span class="o">=</span> <span class="nf">aDifferentValueReturnedByAVeryLongOptionalThingThatForcesTheBraceToBeWrapped</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">guard</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="nf">aValueReturnedByAVeryLongOptionalThing</span><span class="p">(),</span>
      <span class="k">let</span> <span class="nv">value2</span> <span class="o">=</span> <span class="nf">aDifferentValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">guard</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="nf">aValueReturnedByAVeryLongOptionalThing</span><span class="p">(),</span>
      <span class="k">let</span> <span class="nv">value2</span> <span class="o">=</span> <span class="nf">aDifferentValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">element</span> <span class="k">in</span> <span class="n">collection</span>
    <span class="k">where</span> <span class="n">element</span><span class="o">.</span><span class="n">happensToHaveAVeryLongPropertyNameThatYouNeedToCheck</span> <span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="其他表达">其他表达</h4>

<p>非函数调用（上面列举的都是函数调用）的其他表达式换行时，第二行（在第一个换行后的行）的缩进在原始行的基础上 +2。</p>

<p>当有多个后续行时，缩进会根据需要在原来的基础上 +2 递增变化。通常来说，当且仅当两个后续行以语法上平级的元素开始时，才使用相同的缩进。然而，如果因为很长的表达式产生了很多个后续行，考虑用临时变量将它分隔成多个语句。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="n">anExpression</span> <span class="o">+</span> <span class="n">thatIsMadeUpOf</span> <span class="o">*</span> <span class="n">aLargeNumber</span> <span class="o">+</span>
  <span class="n">ofTerms</span> <span class="o">/</span> <span class="n">andTherefore</span> <span class="o">%</span> <span class="n">mustBeWrapped</span> <span class="o">+</span> <span class="p">(</span>
    <span class="n">andWeWill</span> <span class="o">-</span> <span class="n">keepMakingItLonger</span> <span class="o">*</span> <span class="n">soThatWeHave</span> <span class="o">/</span> <span class="n">aContrivedExample</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="n">anExpression</span> <span class="o">+</span> <span class="n">thatIsMadeUpOf</span> <span class="o">*</span> <span class="n">aLargeNumber</span> <span class="o">+</span>
    <span class="n">ofTerms</span> <span class="o">/</span> <span class="n">andTherefore</span> <span class="o">%</span> <span class="n">mustBeWrapped</span> <span class="o">+</span> <span class="p">(</span>
        <span class="n">andWeWill</span> <span class="o">-</span> <span class="n">keepMakingItLonger</span> <span class="o">*</span> <span class="n">soThatWeHave</span> <span class="o">/</span> <span class="n">aContrivedExample</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="水平空格">水平空格</h3>

<blockquote>
  <p><strong>术语说明：</strong>在这个章节，<em>水平空格</em>指的是<em>内部</em>空格。这些规则不适用于行开始时需要或禁止的额外空格。</p>
</blockquote>

<p>根据语言要求或其他代码风格的规则，除了字面量和注释外的单个 Unicode 空格<strong>只能</strong>在下面这些情况出现：</p>

<ol>
  <li>条件或 switch 语句（例如 <code class="language-plaintext highlighter-rouge">if</code>、<code class="language-plaintext highlighter-rouge">guard</code>、<code class="language-plaintext highlighter-rouge">while</code> 或者 <code class="language-plaintext highlighter-rouge">switch</code>）开始的任何保留关键字要和它之后的表达式分隔开，如果该表达式以左括号（<code class="language-plaintext highlighter-rouge">(</code>）开始。</li>
</ol>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>在同一行代码后面的右花括号（<code class="language-plaintext highlighter-rouge">}</code>）之前，任何左花括号（<code class="language-plaintext highlighter-rouge">{</code>）之前，后续代码在同一行的左花括号（<code class="language-plaintext highlighter-rouge">{</code>）之后。</li>
</ol>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">nonNegativeCubes</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="p">}</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">nonNegativeCubes</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="p">}</span> <span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">}</span>
<span class="k">let</span> <span class="nv">nonNegativeCubes</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span><span class="p">}</span><span class="o">.</span><span class="n">filter</span><span class="p">{</span><span class="nv">$0</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>
    <p>在二元或者三元运算符的每一侧，包括下面描述的“类运算符”，除了最后的例外：</p>

    <ol>
      <li>
        <p><code class="language-plaintext highlighter-rouge">=</code> 运算符用在赋值，变量/属性的构造过程以及函数里的默认实参时。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">var</span> <span class="nv">x</span> <span class="o">=</span> <span class="mi">5</span>

 <span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">],</span> <span class="nv">initialValue</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// ...</span>
 <span class="p">}</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">var</span> <span class="nv">x</span><span class="o">=</span><span class="mi">5</span>

 <span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">],</span> <span class="nv">initialValue</span><span class="p">:</span> <span class="kt">Int</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// ...</span>
 <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>And 符号（<code class="language-plaintext highlighter-rouge">&amp;</code>）用在协议组合类型时。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">func</span> <span class="nf">sayHappyBirthday</span><span class="p">(</span><span class="n">to</span> <span class="nv">person</span><span class="p">:</span> <span class="kt">NameProviding</span> <span class="o">&amp;</span> <span class="kt">AgeProviding</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// ...</span>
 <span class="p">}</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">func</span> <span class="nf">sayHappyBirthday</span><span class="p">(</span><span class="n">to</span> <span class="nv">person</span><span class="p">:</span> <span class="kt">NameProviding</span><span class="o">&amp;</span><span class="kt">AgeProviding</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// ...</span>
 <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>运算符用在函数声明/实现时。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span> <span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">MyType</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">MyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
   <span class="c1">// ...</span>
 <span class="p">}</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span><span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">MyType</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">MyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
   <span class="c1">// ...</span>
 <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>箭头（<code class="language-plaintext highlighter-rouge">-&gt;</code>）用在函数的返回类型之前时。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
   <span class="c1">// ...</span>
 <span class="p">}</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span><span class="o">-&gt;</span><span class="kt">Int</span> <span class="p">{</span>
   <span class="c1">// ...</span>
 <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p><strong>例外：</strong>点（<code class="language-plaintext highlighter-rouge">.</code>）用在引用值和类型成员时两侧都没有空格。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">let</span> <span class="nv">width</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">width</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">let</span> <span class="nv">width</span> <span class="o">=</span> <span class="n">view</span> <span class="o">.</span> <span class="n">bounds</span> <span class="o">.</span> <span class="n">width</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p><strong>例外：</strong><code class="language-plaintext highlighter-rouge">..&lt;</code> 或者 <code class="language-plaintext highlighter-rouge">…</code> 运算符用在范围表达式时两侧都没空格。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="mi">1</span><span class="o">...</span><span class="mi">5</span> <span class="p">{</span>
   <span class="c1">// ...</span>
 <span class="p">}</span>

 <span class="k">let</span> <span class="nv">substring</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="n">index</span><span class="o">..&lt;</span><span class="n">string</span><span class="o">.</span><span class="n">endIndex</span><span class="p">]</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="mi">1</span> <span class="o">...</span> <span class="mi">5</span> <span class="p">{</span>
   <span class="c1">// ...</span>
 <span class="p">}</span>

 <span class="k">let</span> <span class="nv">substring</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="n">index</span> <span class="o">..&lt;</span> <span class="n">string</span><span class="o">.</span><span class="n">endIndex</span><span class="p">]</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
  <li>
    <p>逗号（<code class="language-plaintext highlighter-rouge">,</code>）用在形参列表和元组/数组/字典字面量时，在逗号后面而不是前面。</p>
  </li>
</ol>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="p">,</span><span class="mi">2</span> <span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="p">,</span> <span class="mi">2</span> <span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div></div>

<ol>
  <li>
    <p>如果是下列场景，加在冒号（<code class="language-plaintext highlighter-rouge">:</code>）后面而不是前面</p>

    <ol>
      <li>
        <p>父类/协议遵循列表和范型约束。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">struct</span> <span class="kt">HashTable</span><span class="p">:</span> <span class="kt">Collection</span> <span class="p">{</span>
   <span class="c1">// ...</span>
 <span class="p">}</span>

 <span class="kd">struct</span> <span class="kt">AnyEquatable</span><span class="o">&lt;</span><span class="kt">Wrapped</span><span class="p">:</span> <span class="kt">Equatable</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
   <span class="c1">// ...</span>
 <span class="p">}</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">struct</span> <span class="kt">HashTable</span> <span class="p">:</span> <span class="kt">Collection</span> <span class="p">{</span>
   <span class="c1">// ...</span>
 <span class="p">}</span>

 <span class="kd">struct</span> <span class="kt">AnyEquatable</span><span class="o">&lt;</span><span class="kt">Wrapped</span> <span class="p">:</span> <span class="kt">Equatable</span><span class="o">&gt;</span> <span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
   <span class="c1">// ...</span>
 <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>函数实参标签和元组元素标签。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">let</span> <span class="nv">tuple</span><span class="p">:</span> <span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>

 <span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="p">{</span>
   <span class="c1">// ...</span>
 <span class="p">}</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">let</span> <span class="nv">tuple</span><span class="p">:</span> <span class="p">(</span><span class="nv">x</span><span class="p">:</span><span class="kt">Int</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span><span class="kt">Int</span><span class="p">)</span>
 <span class="k">let</span> <span class="nv">tuple</span><span class="p">:</span> <span class="p">(</span><span class="nv">x</span> <span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">y</span> <span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>

 <span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:[</span><span class="kt">Int</span><span class="p">])</span> <span class="p">{</span>
   <span class="c1">// ...</span>
 <span class="p">}</span>

 <span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span> <span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="p">{</span>
   <span class="c1">// ...</span>
 <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>变量/属性的类型显式声明。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">let</span> <span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">let</span> <span class="nv">number</span><span class="p">:</span><span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>
  <span class="k">let</span> <span class="nv">number</span> <span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>字典类型缩写。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">var</span> <span class="nv">nameAgeMap</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">var</span> <span class="nv">nameAgeMap</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
 <span class="k">var</span> <span class="nv">nameAgeMap</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span> <span class="p">:</span> <span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>字典字面量。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">let</span> <span class="nv">nameAgeMap</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Ed"</span><span class="p">:</span> <span class="mi">40</span><span class="p">,</span> <span class="s">"Timmy"</span><span class="p">:</span> <span class="mi">9</span><span class="p">]</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">let</span> <span class="nv">nameAgeMap</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Ed"</span><span class="p">:</span><span class="mi">40</span><span class="p">,</span> <span class="s">"Timmy"</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>
  <span class="k">let</span> <span class="nv">nameAgeMap</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Ed"</span> <span class="p">:</span> <span class="mi">40</span><span class="p">,</span> <span class="s">"Timmy"</span> <span class="p">:</span> <span class="mi">9</span><span class="p">]</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
  <li>
    <p>行尾注释的双斜杠（<code class="language-plaintext highlighter-rouge">//</code>），双斜杠之前最少两个空格，之后只加一个空格。</p>
  </li>
</ol>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">initialFactor</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1">// Warm up the modulator.</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">initialFactor</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1">//    Warm up the modulator.</span>
</code></pre></div></div>

<ol>
  <li>数组、字典或元组字面量定义，加在括号外面而不是里面。</li>
</ol>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">]</span>
</code></pre></div></div>

<h3 id="水平对齐">水平对齐</h3>

<blockquote>
  <p><strong>术语说明：</strong><em>水平对齐</em>是一种约定，通过在代码中添加不同数量的空格，让某些元素直接显示在前面行中该类型的其他元素下面。</p>
</blockquote>

<p>水平对齐是禁止的，除非是明确的表格数据，此时不对齐会降低可读性。其他情况下（例如，对 <code class="language-plaintext highlighter-rouge">struct</code> 或 <code class="language-plaintext highlighter-rouge">class</code> 里的存储属性声明的类型进行对齐）水平对齐会引起维护问题，因为在新的成员引入时其余所有的成员都需要重新对齐。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">DataPoint</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span>
  <span class="k">var</span> <span class="nv">primaryColor</span><span class="p">:</span> <span class="kt">UIColor</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">DataPoint</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">value</span><span class="p">:</span>        <span class="kt">Int</span>
  <span class="k">var</span> <span class="nv">primaryColor</span><span class="p">:</span> <span class="kt">UIColor</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="垂直空行">垂直空行</h3>

<p>在这些情况下使用单独的空白行：</p>

<ol>
  <li>
    <p>在类型中这些连续成员之间：属性、构造器、方法、枚举项、嵌套类型，<strong>除非</strong>：</p>
  </li>
  <li>
    <p>如果两个连续的存储属性，或者两个枚举项可以写在一行中，那空白行就是可选的。这时候空白行可以用来对这些声明进行<em>逻辑分组</em>。</p>

    <ol>
      <li>不适用于前面规则，但两个属性有强关联，那之间的空白行也是可选的。例如，一个私有的存储属性和它相关的公开计算属性。</li>
    </ol>
  </li>
  <li>
    <p>如果用于分割代码，<strong>只在需要的时候使用</strong>，根据逻辑对代码进行分割。</p>
  </li>
  <li>
    <p>类型的第一个成员之前，或者最后一个成员之后的空白行是<em>可选的</em>（不赞成也不反对）。</p>
  </li>
  <li>
    <p>本文档中其他章节中明确要求的地方。</p>
  </li>
</ol>

<p><em>多个</em>空白行是允许的，但不是必须的（不赞成）。如果使用多个连续的空白行，那么在你的代码里应该贯彻到底。</p>

<h3 id="括号">括号</h3>

<p><code class="language-plaintext highlighter-rouge">if</code>、<code class="language-plaintext highlighter-rouge">guard</code>、<code class="language-plaintext highlighter-rouge">while</code> 或 <code class="language-plaintext highlighter-rouge">switch</code> 关键字后面的顶层表达式<strong>不需要</strong>使用括号。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"x is zero"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"..."</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"x is zero"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"..."</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>分组括号是可选的，只有当作者和审查者觉得没有也不会令代码容易误解，或者会让代码更容易阅读时才可以被省略。<strong>不</strong>要认为每个阅读者都能记得完整的 Swift 操作符优先级表格。</p>

<h2 id="特定结构格式化">特定结构格式化</h2>

<h3 id="非文档注释">非文档注释</h3>

<p>非文档注释总是用双斜杠进行格式化（<code class="language-plaintext highlighter-rouge">//</code>），不要使用 C 风格的块格式化（<code class="language-plaintext highlighter-rouge">/* ... */</code>）。</p>

<h3 id="属性">属性</h3>

<p>局部变量尽量声明在接近首次使用的地方，（在合理的情况下）最小化作用域。</p>

<p>除了元组的解构，每个 <code class="language-plaintext highlighter-rouge">let</code> 或者 <code class="language-plaintext highlighter-rouge">var</code> 语句（无论是属性或者局部变量）只声明一个变量。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">a</span> <span class="o">=</span> <span class="mi">5</span>
<span class="k">var</span> <span class="nv">b</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">let</span> <span class="p">(</span><span class="nv">quotient</span><span class="p">,</span> <span class="nv">remainder</span><span class="p">)</span> <span class="o">=</span> <span class="nf">divide</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span>
</code></pre></div></div>

<h3 id="switch-语句">Switch 语句</h3>

<p>枚举项语句的缩进和它们的 switch 语句保持<em>一致</em>；枚举项块里的语句在该缩进基础上 +2 空格。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">order</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">ascending</span><span class="p">:</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Ascending"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">descending</span><span class="p">:</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Descending"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">same</span><span class="p">:</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Same"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">order</span> <span class="p">{</span>
  <span class="k">case</span> <span class="o">.</span><span class="nv">ascending</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Ascending"</span><span class="p">)</span>
  <span class="k">case</span> <span class="o">.</span><span class="nv">descending</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Descending"</span><span class="p">)</span>
  <span class="k">case</span> <span class="o">.</span><span class="nv">same</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Same"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">order</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">ascending</span><span class="p">:</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Ascending"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">descending</span><span class="p">:</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Descending"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">same</span><span class="p">:</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Same"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="枚举项">枚举项</h3>

<p>通常来说，一个 <code class="language-plaintext highlighter-rouge">enum</code> 里每行只有一个 <code class="language-plaintext highlighter-rouge">case</code>。逗号分隔形式只能在枚举项都没有关联值或者原始值时使用，所有枚举项都能从名字明确其含义而不需要额外的注释，就可以写在同一行。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Token</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">comma</span>
  <span class="k">case</span> <span class="n">semicolon</span>
  <span class="k">case</span> <span class="n">identifier</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Token</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">comma</span><span class="p">,</span> <span class="n">semicolon</span><span class="p">,</span> <span class="n">identifier</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Token</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">comma</span>
  <span class="k">case</span> <span class="n">semicolon</span>
  <span class="k">case</span> <span class="nf">identifier</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Token</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">comma</span><span class="p">,</span> <span class="n">semicolon</span><span class="p">,</span> <span class="nf">identifier</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果 <code class="language-plaintext highlighter-rouge">enum</code> 里所有枚举项都需要被声明为 <code class="language-plaintext highlighter-rouge">indirect</code>，那这个 <code class="language-plaintext highlighter-rouge">enum</code> 就声明为 <code class="language-plaintext highlighter-rouge">indirect</code>，单独枚举项前面的关键字可以省略。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">indirect</span> <span class="kd">enum</span> <span class="kt">DependencyGraphNode</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nf">userDefined</span><span class="p">(</span><span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="kt">DependencyGraphNode</span><span class="p">])</span>
  <span class="k">case</span> <span class="nf">synthesized</span><span class="p">(</span><span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="kt">DependencyGraphNode</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">DependencyGraphNode</span> <span class="p">{</span>
  <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">userDefined</span><span class="p">(</span><span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="kt">DependencyGraphNode</span><span class="p">])</span>
  <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">synthesized</span><span class="p">(</span><span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="kt">DependencyGraphNode</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当 <code class="language-plaintext highlighter-rouge">enum</code> 的枚举项没有关联值时，不应该出现空的括号。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">node</span><span class="p">(</span><span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">empty</span>  <span class="c1">// 推荐</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">node</span><span class="p">(</span><span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="p">)</span>
  <span class="k">case</span> <span class="nf">empty</span><span class="p">()</span>  <span class="c1">// 不推荐</span>
<span class="p">}</span>
</code></pre></div></div>

<p>枚举项必须遵循一定的可解释排序逻辑。如果没有明显的排序逻辑，按照枚举项名字的首字母排序。</p>

<p>在下面的例子中，枚举项根据其表示的 HTTP 状态码数字进行排序，并通过空行进行分组。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">HTTPStatus</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">ok</span> <span class="o">=</span> <span class="mi">200</span>

  <span class="k">case</span> <span class="n">badRequest</span> <span class="o">=</span> <span class="mi">400</span>
  <span class="k">case</span> <span class="n">notAuthorized</span> <span class="o">=</span> <span class="mi">401</span>
  <span class="k">case</span> <span class="n">paymentRequired</span> <span class="o">=</span> <span class="mi">402</span>
  <span class="k">case</span> <span class="n">forbidden</span> <span class="o">=</span> <span class="mi">403</span>
  <span class="k">case</span> <span class="n">notFound</span> <span class="o">=</span> <span class="mi">404</span>

  <span class="k">case</span> <span class="n">internalServerError</span> <span class="o">=</span> <span class="mi">500</span>
<span class="p">}</span>
</code></pre></div></div>

<p>同样的枚举，下面这个版本的写法可读性就差一些。尽管枚举项根据字母排序，但是却失去了对关联值含义的表达。</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">HTTPStatus</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">badRequest</span> <span class="o">=</span> <span class="mi">400</span>
  <span class="k">case</span> <span class="n">forbidden</span> <span class="o">=</span> <span class="mi">403</span>
  <span class="k">case</span> <span class="n">internalServerError</span> <span class="o">=</span> <span class="mi">500</span>
  <span class="k">case</span> <span class="n">notAuthorized</span> <span class="o">=</span> <span class="mi">401</span>
  <span class="k">case</span> <span class="n">notFound</span> <span class="o">=</span> <span class="mi">404</span>
  <span class="k">case</span> <span class="n">ok</span> <span class="o">=</span> <span class="mi">200</span>
  <span class="k">case</span> <span class="n">paymentRequired</span> <span class="o">=</span> <span class="mi">402</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="尾随闭包">尾随闭包</h3>

<p>函数重载时，不能出现两个<em>只有</em>尾随闭包的实参名字不同的重载。</p>

<p>考虑下面的例子，这种情况下无法使用尾随闭包语法来调用 <code class="language-plaintext highlighter-rouge">greet</code>：</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="n">enthusiastically</span> <span class="nv">nameProvider</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Hello, </span><span class="se">\(</span><span class="nf">nameProvider</span><span class="p">()</span><span class="se">)</span><span class="s">! It's a pleasure to see you!"</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="n">apathetically</span> <span class="nv">nameProvider</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Oh, look. It's </span><span class="se">\(</span><span class="nf">nameProvider</span><span class="p">()</span><span class="se">)</span><span class="s">."</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">greet</span> <span class="p">{</span> <span class="s">"John"</span> <span class="p">}</span>  
<span class="c1">// 错误：‘greet’ 使用上有歧义</span>
</code></pre></div></div>

<p>要解决这个问题，可以改变函数名的一部分——在这个例子中，可以修改函数的基础名字：</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">greetEnthusiastically</span><span class="p">(</span><span class="n">_</span> <span class="nv">nameProvider</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Hello, </span><span class="se">\(</span><span class="nf">nameProvider</span><span class="p">()</span><span class="se">)</span><span class="s">! It's a pleasure to see you!"</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">greetApathetically</span><span class="p">(</span><span class="n">_</span> <span class="nv">nameProvider</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Oh, look. It's </span><span class="se">\(</span><span class="nf">nameProvider</span><span class="p">()</span><span class="se">)</span><span class="s">."</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">greetEnthusiastically</span> <span class="p">{</span> <span class="s">"John"</span> <span class="p">}</span>
<span class="n">greetApathetically</span> <span class="p">{</span> <span class="s">"not John"</span> <span class="p">}</span>
</code></pre></div></div>

<p>如果一个函数调用有多个闭包实参，那么<em>都不</em>使用尾随闭包语法调用；<em>都</em>需要写出标签并放在在实参列表的括号里。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">UIView</span><span class="o">.</span><span class="nf">animate</span><span class="p">(</span>
  <span class="nv">withDuration</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>
  <span class="nv">animations</span><span class="p">:</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">},</span>
  <span class="nv">completion</span><span class="p">:</span> <span class="p">{</span> <span class="n">finished</span> <span class="k">in</span>
    <span class="c1">// ...</span>
  <span class="p">})</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">UIView</span><span class="o">.</span><span class="nf">animate</span><span class="p">(</span>
  <span class="nv">withDuration</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>
  <span class="nv">animations</span><span class="p">:</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">})</span> <span class="p">{</span> <span class="n">finished</span> <span class="k">in</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>如果函数只有一个闭包实参，并且它是最后的实参，那么<em>永远</em>使用尾随闭包语法调用它，除了下面这些解决歧义或者分析错误的情况：</p>

<ol>
  <li>
    <p>如上面所描述，必须使用带标签的闭包参数，来消除两个其他实参列表都相同的重载之间的歧义。</p>
  </li>
  <li>
    <p>在控制流语句里必须使用带标签的闭包实参，因为尾随闭包会被解析成控制流语句的执行体。</p>
  </li>
</ol>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Timer</span><span class="o">.</span><span class="nf">scheduledTimer</span><span class="p">(</span><span class="nv">timeInterval</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="nv">repeats</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span> <span class="n">timer</span> <span class="k">in</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Timer done!"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="k">let</span> <span class="nv">firstActive</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="nf">first</span><span class="p">(</span><span class="nv">where</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">isActive</span> <span class="p">})</span> <span class="p">{</span>
  <span class="nf">process</span><span class="p">(</span><span class="n">firstActive</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Timer</span><span class="o">.</span><span class="nf">scheduledTimer</span><span class="p">(</span><span class="nv">timeInterval</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="nv">repeats</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nv">block</span><span class="p">:</span> <span class="p">{</span> <span class="n">timer</span> <span class="k">in</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Timer done!"</span><span class="p">)</span>
<span class="p">})</span>

<span class="c1">// This example fails to compile.</span>
<span class="c1">// 这个例子无法通过编译。</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">firstActive</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="n">first</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">isActive</span> <span class="p">}</span> <span class="p">{</span>
  <span class="nf">process</span><span class="p">(</span><span class="n">firstActive</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果函数调用使用的是尾随闭包语法且没有其他实参，函数名后面的空括号（<code class="language-plaintext highlighter-rouge">()</code>）<em>永远不</em>要出现。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">squares</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">squares</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="nf">map</span><span class="p">({</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="p">})</span>
<span class="k">let</span> <span class="nv">squares</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="nf">map</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="p">}</span>
</code></pre></div></div>

<h3 id="末尾逗号">末尾逗号</h3>

<p>当数组和字典里字面量里每个元素独占一行时，<em>需要</em>加上末尾逗号。在这些字面量后续加入新的元素时，会有更明显的区分。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">configurationKeys</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s">"bufferSize"</span><span class="p">,</span>
  <span class="s">"compression"</span><span class="p">,</span>
  <span class="s">"encoding"</span><span class="p">,</span>                                    <span class="c1">// 推荐</span>
<span class="p">]</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">configurationKeys</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s">"bufferSize"</span><span class="p">,</span>
  <span class="s">"compression"</span><span class="p">,</span>
  <span class="s">"encoding"</span>                                     <span class="c1">// 不推荐</span>
<span class="p">]</span>
</code></pre></div></div>

<h3 id="数字字面量">数字字面量</h3>

<p>如果长数字字面量（十进制、十六进制、八进制和二进制）有数值或存在特定领域分组，建议使用下划线（<code class="language-plaintext highlighter-rouge">_</code>）对数字进行分组，但不强制。</p>

<p>十进制建议每三个数字分组（按千数量级分隔），十六进制建议每四个数字分组，二进制建议每四或八个数字进行分组，或者根据存在的特定值的字段边界进行分组（例如八进制文件权限的三个数字）。</p>

<p>如果字面量是透明标识符且没有数值含义，则不要分组。</p>

<h3 id="注解">注解</h3>

<p>每个带参数的注解（例如 <code class="language-plaintext highlighter-rouge">@availability(…)</code> 或 <code class="language-plaintext highlighter-rouge">@objc(…)</code>）写在其适用声明的前面单独一行，按照首字母排序，缩进和声明保持一致。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@available</span><span class="p">(</span><span class="n">iOS</span> <span class="mf">9.0</span><span class="p">,</span> <span class="o">*</span><span class="p">)</span>
<span class="kd">public</span> <span class="kd">func</span> <span class="nf">coolNewFeature</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@available</span><span class="p">(</span><span class="n">iOS</span> <span class="mf">9.0</span><span class="p">,</span> <span class="o">*</span><span class="p">)</span> <span class="kd">public</span> <span class="kd">func</span> <span class="nf">coolNewFeature</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>不带参数的注解（例如不带参数的 <code class="language-plaintext highlighter-rouge">@objc</code>、<code class="language-plaintext highlighter-rouge">@IBOutlet</code> 或者 <code class="language-plaintext highlighter-rouge">@NSManaged</code>）当且仅当不导致换行时，<em>可以</em>按首字母排序与声明写在同一行。如果在声明的行增加该注解后导致需要换行的话，则将注解另起一行。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">MyViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
  <span class="kd">@IBOutlet</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="o">!</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="命名">命名</h2>

<h3 id="apple-api-代码风格指南">Apple API 代码风格指南</h3>

<p>Apple 官方的 <a href="https://swift.org/documentation/api-design-guidelines/">Swift 命名和 API 代码风格指南</a> 也是本文档的一部分，同样需要遵循，这里不再重复其内容。</p>

<blockquote>
  <p>译者注：这份文档的中文版是 SwiftGG 的长期维护项目之一，可以在 <a href="https://github.com/SketchK/the-swift-api-design-guidelines-in-chinese">这里</a> 阅读。</p>
</blockquote>

<h3 id="命名约定不是访问控制">命名约定不是访问控制</h3>

<p>使用约定俗成的访问控制（<code class="language-plaintext highlighter-rouge">internal</code>、<code class="language-plaintext highlighter-rouge">fileprivate</code> 或 <code class="language-plaintext highlighter-rouge">private</code>）来达到隐藏信息的目的，不要使用命名约定。</p>

<p>命名约定（例如下划线前缀）只有在声明必须用到更高的可见性来解决语言限制的罕见情况下使用——例如，类型有一个方法，只打算被另一个库的实现跨模块调用，导致必须被声明为 <code class="language-plaintext highlighter-rouge">public</code>。</p>

<h3 id="标识符">标识符</h3>

<p>通常来说，标识符只能包含 7 位 ASCII 码字符。Unicode 标识符只有在代码所需要解决的问题领域有明确且合理的含义（例如：希腊字母用于表达数学上的概念），并且能被团队成员理解的情况下才可以使用。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">smile</span> <span class="o">=</span> <span class="s">"😊"</span>
<span class="k">let</span> <span class="nv">deltaX</span> <span class="o">=</span> <span class="n">newX</span> <span class="o">-</span> <span class="n">previousX</span>
<span class="k">let</span> <span class="nv">Δx</span> <span class="o">=</span> <span class="n">newX</span> <span class="o">-</span> <span class="n">previousX</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">😊</span> <span class="o">=</span> <span class="s">"😊"</span>
</code></pre></div></div>

<h3 id="构造器">构造器</h3>

<p>为了代码可读性，构造器实参和其直接对应的存储属性同名。在赋值的时候使用显式 <code class="language-plaintext highlighter-rouge">self.</code> 来消除歧义。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Person</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
  <span class="kd">public</span> <span class="k">let</span> <span class="nv">phoneNumber</span><span class="p">:</span> <span class="kt">String</span>

  <span class="c1">// 推荐</span>
  <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">phoneNumber</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">self</span><span class="o">.</span><span class="n">phoneNumber</span> <span class="o">=</span> <span class="n">phoneNumber</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Person</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
  <span class="kd">public</span> <span class="k">let</span> <span class="nv">phoneNumber</span><span class="p">:</span> <span class="kt">String</span>

  <span class="c1">// 不推荐</span>
  <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">name</span> <span class="nv">otherName</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">phoneNumber</span> <span class="nv">otherPhoneNumber</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">otherName</span>
    <span class="n">phoneNumber</span> <span class="o">=</span> <span class="n">otherPhoneNumber</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="静态属性和类属性">静态属性和类属性</h3>

<p>静态属性和类属性返回声明类型的实例时，<strong>不需要</strong>加上该类型名字作后缀。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">UIColor</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="k">var</span> <span class="nv">red</span><span class="p">:</span> <span class="kt">UIColor</span> <span class="p">{</span>                <span class="c1">// 推荐</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="kt">URLSession</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="k">var</span> <span class="nv">shared</span><span class="p">:</span> <span class="kt">URLSession</span> <span class="p">{</span>          <span class="c1">// 推荐</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">UIColor</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="k">var</span> <span class="nv">redColor</span><span class="p">:</span> <span class="kt">UIColor</span> <span class="p">{</span>           <span class="c1">// 不推荐</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="kt">URLSession</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="k">var</span> <span class="nv">sharedSession</span><span class="p">:</span> <span class="kt">URLSession</span> <span class="p">{</span>   <span class="c1">// 不推荐</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果静态属性或者类属性用于描述该声明类型的单例实例，通常使用 <code class="language-plaintext highlighter-rouge">shared</code> 和 <code class="language-plaintext highlighter-rouge">default</code> 作为名字。本指南不强制要求使用这些命名，作者可以自行选择对该类型有意义的名字。</p>

<h3 id="全局常量">全局常量</h3>

<p>和其他变量类似，全局常量也使用 <code class="language-plaintext highlighter-rouge">lowerCamelCase（驼峰命名法）</code>。不要使用匈牙利命名法，例如以 <code class="language-plaintext highlighter-rouge">g</code> 或者 <code class="language-plaintext highlighter-rouge">k</code> 开头。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">secondsPerMinute</span> <span class="o">=</span> <span class="mi">60</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">SecondsPerMinute</span> <span class="o">=</span> <span class="mi">60</span>
<span class="k">let</span> <span class="nv">kSecondsPerMinute</span> <span class="o">=</span> <span class="mi">60</span>
<span class="k">let</span> <span class="nv">gSecondsPerMinute</span> <span class="o">=</span> <span class="mi">60</span>
<span class="k">let</span> <span class="nv">SECONDS_PER_MINUTE</span> <span class="o">=</span> <span class="mi">60</span>
</code></pre></div></div>

<h3 id="代理方法">代理方法</h3>

<p>受 Cocoa 框架里协议的命名启发，代理协议和类似代理的协议（例如数据源协议）里的方法命名，使用下面描述的口语化语法。</p>

<blockquote>
  <p>术语“代理源对象”指的是响应代理方法的对象。例如：<code class="language-plaintext highlighter-rouge">UITableView</code> 是响应视图 <code class="language-plaintext highlighter-rouge">delegate</code> 属性设置的 <code class="language-plaintext highlighter-rouge">UITableViewDeleagte</code> 里方法的源对象。</p>
</blockquote>

<p>所有方法将代理源对象作为第一个实参。</p>

<p>对于<strong>只</strong>有代理源对象实参的方法：</p>

<ul>
  <li>
    <p>如果方法返回 <code class="language-plaintext highlighter-rouge">void</code>（例如用于提醒代理事件发生），那么方法名为<strong>代理源类型</strong>后面加上描述事件的<strong>指示性动词</strong>。实参<strong>无标签</strong>。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">scrollViewDidBeginScrolling</span><span class="p">(</span><span class="n">_</span> <span class="nv">scrollView</span><span class="p">:</span> <span class="kt">UIScrollView</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>如果方法返回 <code class="language-plaintext highlighter-rouge">Bool</code>（例如对代理源对象本身做断言），那么方法名为<strong>代理源类型</strong>后面加上描述断言的<strong>指示性或条件性动词</strong>。实参<strong>无标签</strong>。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">scrollViewShouldScrollToTop</span><span class="p">(</span><span class="n">_</span> <span class="nv">scrollView</span><span class="p">:</span> <span class="kt">UIScrollView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>如果方法返回其他值（例如查询代理源对象上的属性信息），那么方法名是描述查询属性的<strong>名词</strong>。实参<strong>标签是介词或后置介词</strong>，用于将名词和代理源对象合适地连接起来。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">numberOfSections</span><span class="p">(</span><span class="k">in</span> <span class="nv">scrollView</span><span class="p">:</span> <span class="kt">UIScrollView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>对于在代理源对象后有<strong>额外</strong>实参的方法，方法名是代理源类型<strong>自身</strong>并且第一个实参<strong>无标签</strong>。然后：</p>

<ul>
  <li>
    <p>如果方法返回 <code class="language-plaintext highlighter-rouge">void</code>，第二个实参<strong>标签是指示性动词</strong>，用于描述实参是<strong>直接宾语或者间接宾语</strong>的事件，并给其它实参（如果有的话）提供更多上下文。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span>
<span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span>
  <span class="n">willDisplayCell</span> <span class="nv">cell</span><span class="p">:</span> <span class="kt">UITableViewCell</span><span class="p">,</span>
  <span class="n">forRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>如果方法返回 <code class="language-plaintext highlighter-rouge">Bool</code>，第二个实参<strong>标签是指示性或者条件性动词</strong>，用于描述对于实参的返回值，并给其他实参（如果有的话）提供更多上下文。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span>
<span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span>
  <span class="n">shouldSpringLoadRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">,</span>
  <span class="n">with</span> <span class="nv">context</span><span class="p">:</span> <span class="kt">UISpringLoadedInteractionContext</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>如果方法返回其他值，第二个实参<strong>标签是名词和后置介词</strong>，用于描述对于实参的返回值，并给其他实参（如果有的话）提供更多上下文。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span>
<span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span>
  <span class="n">heightForRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">CGFloat</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>Apple 的 <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/DelegatesandDataSources/DelegatesandDataSources.html">代理和数据源</a> 文档也提供了一些在这种情况下的通用命名指引。</p>

<h2 id="编程实践">编程实践</h2>

<p>本章节中规则的通用主旨是：避免冗余，避免歧义，除了能明显提高可读性和/或减少歧义外，尽量使用隐式而不是显式。</p>

<h3 id="编译器警告">编译器警告</h3>

<p>代码在编译时尽可能保持没有警告。在作者力所能及的范围内去除警告。</p>

<p>如果不能马上迁移到替代 API，或者在 API 对外部用户废弃但还需要继续对库内部支持时，有理由的废弃警告可以保留。</p>

<h3 id="构造器-1">构造器</h3>

<p>对于 <code class="language-plaintext highlighter-rouge">Struct</code>，Swift 会合成实参为 <code class="language-plaintext highlighter-rouge">var</code> 属性和缺少默认值的 <code class="language-plaintext highlighter-rouge">let</code> 属性的非公开逐一成员 <code class="language-plaintext highlighter-rouge">init</code>。如果该构造器已经足够（也就是说不需要 <code class="language-plaintext highlighter-rouge">public</code>），直接使用，不需要写显式的构造器。</p>

<p>永远不要直接调用遵循特殊 <code class="language-plaintext highlighter-rouge">ExpressibleBy*Literal</code> 编译器协议的构造器。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Kilometers</span><span class="p">:</span> <span class="kt">ExpressibleByIntegerLiteral</span> <span class="p">{</span>
  <span class="nf">init</span><span class="p">(</span><span class="n">integerLiteral</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">k1</span><span class="p">:</span> <span class="kt">Kilometers</span> <span class="o">=</span> <span class="mi">10</span>                          <span class="c1">// 推荐</span>
<span class="k">let</span> <span class="nv">k2</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">as</span> <span class="kt">Kilometers</span>                        <span class="c1">// 推荐</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Kilometers</span><span class="p">:</span> <span class="kt">ExpressibleByIntegerLiteral</span> <span class="p">{</span>
  <span class="nf">init</span><span class="p">(</span><span class="n">integerLiteral</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">k</span> <span class="o">=</span> <span class="kt">Kilometers</span><span class="p">(</span><span class="nv">integerLiteral</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>           <span class="c1">// 不推荐</span>
</code></pre></div></div>

<p>只有当调用者是元类型变量时才允许明确调用 <code class="language-plaintext highlighter-rouge">.init(...)</code>。使用字面量类型名字直接调用构造器时，省略 <code class="language-plaintext highlighter-rouge">.init</code>。（构造器使用 <code class="language-plaintext highlighter-rouge">MyType.init</code> 语法作为闭包进行<strong>引用</strong>是允许的。）</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="kt">MyType</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">type</span> <span class="o">=</span> <span class="nf">lookupType</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="n">type</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="nf">makeValue</span><span class="p">(</span><span class="nv">factory</span><span class="p">:</span> <span class="kt">MyType</span><span class="o">.</span><span class="kd">init</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="kt">MyType</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="属性-1">属性</h3>

<p>只读计算属性的 <code class="language-plaintext highlighter-rouge">get</code> 块可以省略，将执行体直接嵌套在属性声明里。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">totalCost</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">items</span><span class="o">.</span><span class="n">sum</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">cost</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">totalCost</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">get</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">items</span><span class="o">.</span><span class="n">sum</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">cost</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="类型简称">类型简称</h3>

<p>数组、字典和可选类型尽可能使用简写形式，也就是 <code class="language-plaintext highlighter-rouge">[Element]</code>，<code class="language-plaintext highlighter-rouge">[Key: Value]</code> 和 <code class="language-plaintext highlighter-rouge">Wrapped?</code>。完整形式 <code class="language-plaintext highlighter-rouge">Array&lt;Element&gt;</code>，<code class="language-plaintext highlighter-rouge">Dictionary&lt;Key, Value&gt;</code> 和 <code class="language-plaintext highlighter-rouge">Optional&lt;Wrapped&gt;</code> 只有在编译器需要时才使用，例如 Swift 语法分析程序不接受 <code class="language-plaintext highlighter-rouge">[Element].Index</code> 而需要用 <code class="language-plaintext highlighter-rouge">Array&lt;Element&gt;.Index</code>。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">enumeratedDictionary</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">from</span> <span class="nv">values</span><span class="p">:</span> <span class="p">[</span><span class="kt">Element</span><span class="p">],</span>
  <span class="nv">start</span><span class="p">:</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;.</span><span class="kt">Index</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">:</span> <span class="kt">Element</span><span class="p">]</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">enumeratedDictionary</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">from</span> <span class="nv">values</span><span class="p">:</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nv">start</span><span class="p">:</span> <span class="kt">Optional</span><span class="o">&lt;</span><span class="kt">Array</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;.</span><span class="kt">Index</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Dictionary</span><span class="o">&lt;</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Element</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Void</code> 是空元组 <code class="language-plaintext highlighter-rouge">()</code> 的 <code class="language-plaintext highlighter-rouge">typealias</code>，所以从实现来说它们是等价的。在函数类型声明（例如闭包或者持有函数引用变量）的返回类型永远写作 <code class="language-plaintext highlighter-rouge">void</code>，而不用 <code class="language-plaintext highlighter-rouge">()</code>。在用 <code class="language-plaintext highlighter-rouge">func</code> 关键字声明的函数中，全都省略 <code class="language-plaintext highlighter-rouge">void</code> 返回类型。</p>

<p>空的实参列表永远写作 <code class="language-plaintext highlighter-rouge">()</code>，而不是 <code class="language-plaintext highlighter-rouge">Void</code>。（事实上，<code class="language-plaintext highlighter-rouge">Void -&gt; Result</code> 的函数签名在 Swift 里会报错，因为函数实参必须用括号包围，而 <code class="language-plaintext highlighter-rouge">(void)</code> 有着其他含义：单个空元组实参的实参列表。）</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">callback</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Void</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Void</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">doSomething2</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">callback</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">()</span>
</code></pre></div></div>

<h3 id="可选类型">可选类型</h3>

<p>在设计算法时避免哨兵值（例如 <code class="language-plaintext highlighter-rouge">index</code> 是 -1 表示集合里找不到某个元素）。哨兵值容易被偶然传递到其它逻辑层，因为类型系统没办法将它们和合法结果进行区分。</p>

<p><code class="language-plaintext highlighter-rouge">Optional</code> 用于传递一个非错误的结果，要不有值，要不没有值。例如：在集合中查询一个值时，值没有找到是一个<strong>合法并可预期</strong>的结果，而不是一个错误。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">index</span><span class="p">(</span><span class="n">of</span> <span class="nv">thing</span><span class="p">:</span> <span class="kt">Thing</span><span class="p">,</span> <span class="k">in</span> <span class="nv">things</span><span class="p">:</span> <span class="p">[</span><span class="kt">Thing</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">?</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">if</span> <span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="nf">index</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">thing</span><span class="p">,</span> <span class="nv">in</span><span class="p">:</span> <span class="n">lotsOfThings</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 找到了</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// 没找到</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">index</span><span class="p">(</span><span class="n">of</span> <span class="nv">thing</span><span class="p">:</span> <span class="kt">Thing</span><span class="p">,</span> <span class="k">in</span> <span class="nv">things</span><span class="p">:</span> <span class="p">[</span><span class="kt">Thing</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="nf">index</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">thing</span><span class="p">,</span> <span class="nv">in</span><span class="p">:</span> <span class="n">lotsOfThings</span><span class="p">)</span>
<span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
  <span class="c1">// 找到了</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// 没找到</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Optional</code> 也用于表示单一而明确失败的错误哨兵，也就是当操作是因为使用者明确的单个特定领域原因而失败时。（限制在特定领域，是为了排除那些用户明显无法正确处理的严重错误，例如内存不足错误。）</p>

<p>例如，如果字符串不能用适合类型位宽的合法整数表达，将字符串转换为整型可能会失败：</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Int17</span> <span class="p">{</span>
  <span class="nf">init</span><span class="p">?(</span><span class="n">_</span> <span class="nv">string</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果要判断一个 <code class="language-plaintext highlighter-rouge">Optional</code> 非 <code class="language-plaintext highlighter-rouge">nil</code> 但不需要访问解包值，可以直接和 <code class="language-plaintext highlighter-rouge">nil</code> 进行比较。下面的例子能清晰地表达程序意图：</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"value was not nil"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个例子里，用到了 Swift 模式匹配和绑定语法，将值解包后又马上丢弃，这就会让人产生误解（译者注：程序的目的是判断有没有值，但是这种写法看起来并不直观，好像有其他意图）。</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">value</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"value was not nil"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="错误">错误</h3>

<p>错误类型在错误有多种可能的状态时使用。</p>

<p>将错误抛出而不是随着返回值返回，可以更清晰地将问题从 API 里分离。合法输入和合法状态在结果域里产生合法输出，并通过标准的控制流进行处理。非法输入和非法状态应视作错误，并使用相关语法结构进行处理（<code class="language-plaintext highlighter-rouge">do</code>-<code class="language-plaintext highlighter-rouge">catch</code> 和 <code class="language-plaintext highlighter-rouge">try</code>）。例如：</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Document</span> <span class="p">{</span>
  <span class="kd">enum</span> <span class="kt">ReadError</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">notFound</span>
    <span class="k">case</span> <span class="n">permissionDenied</span>
    <span class="k">case</span> <span class="n">malformedHeader</span>
  <span class="p">}</span>

  <span class="nf">init</span><span class="p">(</span><span class="nv">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">do</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">document</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">Document</span><span class="p">(</span><span class="nv">path</span><span class="p">:</span> <span class="s">"important.data"</span><span class="p">)</span>
<span class="p">}</span> <span class="k">catch</span> <span class="kt">Document</span><span class="o">.</span><span class="kt">ReadError</span><span class="o">.</span><span class="n">notFound</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span> <span class="k">catch</span> <span class="kt">Document</span><span class="o">.</span><span class="kt">ReadError</span><span class="o">.</span><span class="n">permissionDenied</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>下面这样的设计能迫使调用者有意识地面对错误：</p>

<ul>
  <li>将代码包在 <code class="language-plaintext highlighter-rouge">do</code>-<code class="language-plaintext highlighter-rouge">catch</code> 块里调用，并根据错误严重程度进行处理，</li>
  <li>将函数声明为在调用时 <code class="language-plaintext highlighter-rouge">throws</code> 并将错误传递给上层，或者</li>
  <li>在某些不重要失败原因并且只需要调用是否失败的信息时使用 <code class="language-plaintext highlighter-rouge">try?</code> 。</li>
</ul>

<p>通常来说，除了下面的说明以外，<code class="language-plaintext highlighter-rouge">try!</code> 是禁止的；它等同于对 <code class="language-plaintext highlighter-rouge">fatalError</code> 使用 <code class="language-plaintext highlighter-rouge">try</code> 但却没有有意义的信息。如果某个错误的发生意味着程序处在无法恢复的状态，那么立即终止是唯一合理的动作，这时使用 <code class="language-plaintext highlighter-rouge">do</code>-<code class="language-plaintext highlighter-rouge">catch</code> 或者 <code class="language-plaintext highlighter-rouge">try?</code> 并提供错误的更多上下文信息，可以更好地帮助调试。</p>

<blockquote>
  <p><strong>例外：</strong><code class="language-plaintext highlighter-rouge">try!</code> 在单元测试和仅用于测试的代码中允许使用。如果确定错误抛出只可能由<strong>编程人员</strong>导致，也可以在非测试代码里使用；我们特别定义这种情况，是因为在 Swift REPL 里有些单个表达式没有上下文就无法被推断。例如，考虑通过字符串字面量来构造正则表达式的情况：</p>

  <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">regex</span> <span class="o">=</span> <span class="k">try!</span> <span class="kt">NSRegularExpression</span><span class="p">(</span><span class="nv">pattern</span><span class="p">:</span> <span class="s">"a*b+c?"</span><span class="p">)</span>
</code></pre></div>  </div>

  <p><code class="language-plaintext highlighter-rouge">NSRegularExpression</code> 构造器会在正则表达式不合法时抛出错误，但当它是字符串字面量时，错误只可能由于编程人员的编写错误导致。这时候编写额外的错误处理逻辑并没有什么益处。</p>

  <p>如果上面 pattern 不是字面量，而是动态生成的或者是使用者传入的，则<strong>不</strong>应该使用 <code class="language-plaintext highlighter-rouge">try!</code>，应该更优雅地处理出现的错误。</p>
</blockquote>

<h3 id="强制解包和强制类型转换">强制解包和强制类型转换</h3>

<p>强制解包和强制类型转换通常说明代码有问题，强烈不推荐。除非它能通过周围代码解释清楚该操作的安全性，并需要附加注释来描述这个操作是永远安全的。例如，</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="nf">getSomeInteger</span><span class="p">()</span>

<span class="c1">// ...无关代码...</span>

<span class="c1">// 这里的强制解包是安全的，会保证传入的 `value` 是合法的，因为它的数据源只提供这些合法枚举项</span>
<span class="k">return</span> <span class="kt">SomeEnum</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span><span class="o">!</span>
</code></pre></div></div>

<blockquote>
  <p><strong>例外：</strong>在单元测试和仅用于测试的代码里，允许使用没有注释的强制解包。这可以减少代码中不必要的控制流。在 <code class="language-plaintext highlighter-rouge">nil</code> 被解包或者不合适的类型擦除发生时，测试也会按照预期而失败。</p>
</blockquote>

<h3 id="可选值隐式解包">可选值隐式解包</h3>

<p>可选值隐式解包本身是不安全的，尽可能使用非可选值声明，或者使用常规的 <code class="language-plaintext highlighter-rouge">Optional</code> 类型。下面是一些特殊情况。</p>

<p>存活时间基于 UI 生命周期而不是严格基于持有关系的用户界面元素，可以使用可选值显式解包。这种情况的例子包括连接 XIB 文件或 storyboard 中元素的 <code class="language-plaintext highlighter-rouge">@IBOutlet</code> 属性，外部初始化的属性（例如 view controller 调用的 <code class="language-plaintext highlighter-rouge">prepareForSegue</code> 实现），还有在类生命周期中初始化的属性（例如在 view controller <code class="language-plaintext highlighter-rouge">viewDidLoad</code> 方法里初始化的视图）。这些属性如果用可选值，会加重使用者解包的负担，因为它们能确保非空，并且一旦初始化完毕就会一直有值。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SomeViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
  <span class="kd">@IBOutlet</span> <span class="k">var</span> <span class="nv">button</span><span class="p">:</span> <span class="kt">UIButton</span><span class="o">!</span>

  <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">populateLabel</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">button</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="kd">private</span> <span class="kd">func</span> <span class="nf">populateLabel</span><span class="p">(</span><span class="k">for</span> <span class="nv">button</span><span class="p">:</span> <span class="kt">UIButton</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果在 Swift 中使用不支持可空属性的 Objective-C API，也可能用到可选值隐式解包。如果可能的话，让代码的维护者进行修改，从而能在 Swift 中正常使用可选值。如果没有可能，尽可能缩小这些可选值隐式解包在 Swift 代码中的影响；也就是说，不要将它们扩散到多个你自己的抽象层中。</p>

<p>可选值隐式解包在单元测试中可以使用。这和上面的 UI 元素情况理由差不多——测试里对象的生命周期通常不从测试构造器开始，而是从测试的 <code class="language-plaintext highlighter-rouge">setUp()</code> 方法开始，以便在每次测试执行前重置。</p>

<h3 id="访问等级">访问等级</h3>

<p>在声明里省略显式的访问等级是允许的。顶层声明的默认访问等级是 <code class="language-plaintext highlighter-rouge">internal</code>。嵌套的声明默认访问等级和其外层声明访问等级相同，但不能高于 <code class="language-plaintext highlighter-rouge">internal</code> 。</p>

<p>给文件级别的扩展指定显式访问等级是不允许的。拓展里的每一个成员如果不采用默认的访问等级，则应该单独进行指定。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">isUppercase</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="kd">public</span> <span class="k">var</span> <span class="nv">isLowercase</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">extension</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">isUppercase</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="k">var</span> <span class="nv">isLowercase</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="嵌套和命名空间">嵌套和命名空间</h3>

<p>Swift 里允许嵌套 <code class="language-plaintext highlighter-rouge">enum</code>、<code class="language-plaintext highlighter-rouge">struct</code> 和 <code class="language-plaintext highlighter-rouge">class</code>，嵌套更适合（比起命名约定）表示作用域和类型之间的分级关系，因此推荐使用。例如，把类型相关的 <code class="language-plaintext highlighter-rouge">enum</code> 或者错误类型放到这个类型内部。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Parser</span> <span class="p">{</span>
  <span class="kd">enum</span> <span class="kt">Error</span><span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Error</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">invalidToken</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">unexpectedEOF</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">parse</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Parser</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">parse</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="kt">ParseError</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nf">invalidToken</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">unexpectedEOF</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Swift 目前还不支持在其它类型中嵌套协议，反之亦然，所以该规则不适用于某些情况，例如控制器类型和它的代理协议。</p>

<p>如果要定一个“命名空间”来对互相关联的声明（例如常量或者帮助方法）就行分组，公认的做法是声明一个没有枚举项的 <code class="language-plaintext highlighter-rouge">enum</code>。该 <code class="language-plaintext highlighter-rouge">enum</code> 自然不存在实例，并且不需要额外的样板代码来避免被实例化。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Dimensions</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="k">let</span> <span class="nv">tileMargin</span><span class="p">:</span> <span class="kt">CGFloat</span> <span class="o">=</span> <span class="mi">8</span>
  <span class="kd">static</span> <span class="k">let</span> <span class="nv">tilePadding</span><span class="p">:</span> <span class="kt">CGFloat</span> <span class="o">=</span> <span class="mi">4</span>
  <span class="kd">static</span> <span class="k">let</span> <span class="nv">tileContentSize</span><span class="p">:</span> <span class="kt">CGSize</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">64</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Dimensions</span> <span class="p">{</span>
  <span class="kd">private</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{}</span>

  <span class="kd">static</span> <span class="k">let</span> <span class="nv">tileMargin</span><span class="p">:</span> <span class="kt">CGFloat</span> <span class="o">=</span> <span class="mi">8</span>
  <span class="kd">static</span> <span class="k">let</span> <span class="nv">tilePadding</span><span class="p">:</span> <span class="kt">CGFloat</span> <span class="o">=</span> <span class="mi">4</span>
  <span class="kd">static</span> <span class="k">let</span> <span class="nv">tileContentSize</span><span class="p">:</span> <span class="kt">CGSize</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">64</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="提前退出的-guard">提前退出的 <code class="language-plaintext highlighter-rouge">guard</code></h3>

<p><code class="language-plaintext highlighter-rouge">guard</code> 语句，比起条件相反的 <code class="language-plaintext highlighter-rouge">if</code> 语句，会更好地从视觉上强调，该检查条件会导致从当前作用域提前退出。</p>

<p>更远了说，<code class="language-plaintext highlighter-rouge">guard</code> 语句通过减少额外嵌套层级（“鞭尸金字塔”）来提高可读性；令错误情况和触发条件靠近，而主逻辑在作用域里保持向左对齐。</p>

<p>下面的例子中会体现这些理论；第一种例子里，有清晰的流程，检查不合法的状态并退出，然后在成功的情况下执行主逻辑。在没有 <code class="language-plaintext highlighter-rouge">guard</code> 的第二个例子里，主逻辑混杂在某个任意嵌套层级里，抛出的错误和它们的触发条件被分隔得很开。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">discombobulate</span><span class="p">(</span><span class="n">_</span> <span class="nv">values</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">guard</span> <span class="k">let</span> <span class="nv">first</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">first</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="kt">DiscombobulationError</span><span class="o">.</span><span class="n">arrayWasEmpty</span>
  <span class="p">}</span>
  <span class="k">guard</span> <span class="n">first</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="kt">DiscombobulationError</span><span class="o">.</span><span class="n">negativeEnergy</span>
  <span class="p">}</span>

  <span class="k">var</span> <span class="nv">result</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="n">values</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="nf">invertedCombobulatoryFactory</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">discombobulate</span><span class="p">(</span><span class="n">_</span> <span class="nv">values</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="k">let</span> <span class="nv">first</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">first</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">first</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">var</span> <span class="nv">result</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="n">values</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="nf">invertedCombobulatoryFactor</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">result</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="kt">DiscombobulationError</span><span class="o">.</span><span class="n">negativeEnergy</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="kt">DiscombobulationError</span><span class="o">.</span><span class="n">arrayWasEmpty</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在循环语句中，<code class="language-plaintext highlighter-rouge">guard</code>-<code class="language-plaintext highlighter-rouge">continue</code> 语句也可以避免增加缩进，比如整个循环体只在某些情况下执行（不过要结合下面的 <code class="language-plaintext highlighter-rouge">for</code>-<code class="language-plaintext highlighter-rouge">where</code> 规范）。</p>

<h3 id="for-where-循环"><code class="language-plaintext highlighter-rouge">for</code>-<code class="language-plaintext highlighter-rouge">where</code> 循环</h3>

<p>当整个 <code class="language-plaintext highlighter-rouge">for</code> 循环体只包含对元素的条件检查 <code class="language-plaintext highlighter-rouge">if</code> 块，可以将该检查放在 <code class="language-plaintext highlighter-rouge">for</code> 语句的 <code class="language-plaintext highlighter-rouge">where</code> 分句中。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">collection</span> <span class="k">where</span> <span class="n">item</span><span class="o">.</span><span class="n">hasProperty</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">collection</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">hasProperty</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="在-switch-语句里的-fallthrough">在 <code class="language-plaintext highlighter-rouge">switch</code> 语句里的 <code class="language-plaintext highlighter-rouge">fallthrough</code></h3>

<p>当 <code class="language-plaintext highlighter-rouge">switch</code> 里的多个 <code class="language-plaintext highlighter-rouge">case</code> 执行同样的语句时，这些 <code class="language-plaintext highlighter-rouge">case</code> 可以合并成一个范围或者逗号分隔的列表。声明多个 <code class="language-plaintext highlighter-rouge">case</code> 却不做任何事，只是 <code class="language-plaintext highlighter-rouge">fallthrough</code> 到后面的 <code class="language-plaintext highlighter-rouge">case</code> 是不允许的。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">value</span> <span class="p">{</span>
<span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="s">"one"</span><span class="p">)</span>
<span class="k">case</span> <span class="mi">2</span><span class="o">...</span><span class="mi">4</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="s">"two to four"</span><span class="p">)</span>
<span class="k">case</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="s">"five or seven"</span><span class="p">)</span>
<span class="k">default</span><span class="p">:</span> <span class="k">break</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">value</span> <span class="p">{</span>
<span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="s">"one"</span><span class="p">)</span>
<span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="k">fallthrough</span>
<span class="k">case</span> <span class="mi">3</span><span class="p">:</span> <span class="k">fallthrough</span>
<span class="k">case</span> <span class="mi">4</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="s">"two to four"</span><span class="p">)</span>
<span class="k">case</span> <span class="mi">5</span><span class="p">:</span> <span class="k">fallthrough</span>
<span class="k">case</span> <span class="mi">7</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="s">"five or seven"</span><span class="p">)</span>
<span class="k">default</span><span class="p">:</span> <span class="k">break</span>
<span class="p">}</span>
</code></pre></div></div>

<p>也就是说，不能有<em>只</em>执行 <code class="language-plaintext highlighter-rouge">fallthrough</code> 语句的 <code class="language-plaintext highlighter-rouge">case</code>。包含<em>其余</em>语句再下落（fallthrough）到下一个 <code class="language-plaintext highlighter-rouge">case</code> 是允许的。</p>

<h3 id="模式匹配">模式匹配</h3>

<p><em>每个</em>模式匹配元素前面都有单独的 <code class="language-plaintext highlighter-rouge">let</code> 和 <code class="language-plaintext highlighter-rouge">var</code> 关键字。适用于整个匹配模式的前置简写 <code class="language-plaintext highlighter-rouge">let</code>/<code class="language-plaintext highlighter-rouge">var</code> 是禁止的，因为当匹配模式的值本身是个变量时，会引入非预期行为。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">DataPoint</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nf">unlabeled</span><span class="p">(</span><span class="kt">Int</span><span class="p">)</span>
  <span class="k">case</span> <span class="nf">labeled</span><span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">label</span> <span class="o">=</span> <span class="s">"goodbye"</span>

<span class="c1">// 因为没有前置的 `let`，`label` 在这里是一个值，所以下面的模式匹配中只会匹配标签是“goodbye”的数据点。 </span>
<span class="k">switch</span> <span class="kt">DataPoint</span><span class="o">.</span><span class="nf">labeled</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nf">labeled</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="k">let</span> <span class="nv">value</span><span class="p">):</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// 每个单独的绑定使用前置 `let` 能清晰地表达引入了一个新的绑定（覆盖枚举项里的局部变量），而不是匹配局部变量的值。</span>
<span class="c1">// 这样，这个模式匹配会将数据点和任意字符串标签匹配。</span>
<span class="k">switch</span> <span class="kt">DataPoint</span><span class="o">.</span><span class="nf">labeled</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nf">labeled</span><span class="p">(</span><span class="k">let</span> <span class="nv">label</span><span class="p">,</span> <span class="k">let</span> <span class="nv">value</span><span class="p">):</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在下面的例子中，如果作者意图是使用上面的 <code class="language-plaintext highlighter-rouge">label</code> 变量进行匹配，那么就会因为 <code class="language-plaintext highlighter-rouge">let</code> 适用于整个模式匹配，导致该值会被任何绑定的字符串所覆盖。</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="kt">DataPoint</span><span class="o">.</span><span class="nf">labeled</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">labeled</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>元组的实参标签和 <code class="language-plaintext highlighter-rouge">enum</code> 的关联值在用相同标签名字的变量来绑定值时，可以被省略。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">subtree</span><span class="p">(</span><span class="nv">left</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="k">case</span> <span class="nf">leaf</span><span class="p">(</span><span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">switch</span> <span class="n">treeNode</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nf">subtree</span><span class="p">(</span><span class="k">let</span> <span class="nv">left</span><span class="p">,</span> <span class="k">let</span> <span class="nv">right</span><span class="p">):</span>
  <span class="c1">// ...</span>
<span class="k">case</span> <span class="o">.</span><span class="nf">leaf</span><span class="p">(</span><span class="k">let</span> <span class="nv">element</span><span class="p">):</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>多余并缺乏有用信息的标签只会造成混淆：</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">treeNode</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nf">subtree</span><span class="p">(</span><span class="nv">left</span><span class="p">:</span> <span class="k">let</span> <span class="nv">left</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="k">let</span> <span class="nv">right</span><span class="p">):</span>
  <span class="c1">// ...</span>
<span class="k">case</span> <span class="o">.</span><span class="nf">leaf</span><span class="p">(</span><span class="nv">element</span><span class="p">:</span> <span class="k">let</span> <span class="nv">element</span><span class="p">):</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="元组模式">元组模式</h3>

<p>只有赋值表达式左侧没有标签的元组模式（有时候用<em>乱序元组</em>），才允许进行元组模式变量赋值。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="p">(</span><span class="nv">a</span><span class="p">,</span> <span class="nv">b</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nv">y</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="nv">x</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="p">(</span><span class="nv">x</span><span class="err">:</span> <span class="nv">a</span><span class="p">,</span> <span class="nv">y</span><span class="err">:</span> <span class="nv">b</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nv">y</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="nv">x</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">)</span>
</code></pre></div></div>

<p>左侧的标签与类型注解很类似，会导致代码难以理解。</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 这里声明了两个变量，一个是 `Int` 类型，但实际上是 5.0 的 `Double` 值，另一个是 `Double` 类型，</span>
<span class="c1">// 但实际上是 4 的 `Int` 值。</span>
<span class="c1">// `x` 和 `y` 不是变量。</span>
<span class="k">let</span> <span class="p">(</span><span class="nv">x</span><span class="err">:</span> <span class="nv">Int</span><span class="p">,</span> <span class="nv">y</span><span class="err">:</span> <span class="nv">Double</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nv">y</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="nv">x</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="数字和字符串字面量">数字和字符串字面量</h3>

<p>Swift 里的整型和字符串字面量没有固定类型。例如，<code class="language-plaintext highlighter-rouge">5</code> 本身不是一个 <code class="language-plaintext highlighter-rouge">Int</code>；它能表示遵循 <code class="language-plaintext highlighter-rouge">ExpressibleByIntegerLiteral</code> 的任何类型，只有类型推断无法找到更明确的类型时，才会变成 <code class="language-plaintext highlighter-rouge">Int</code>。类似的，字面量 <code class="language-plaintext highlighter-rouge">"x"</code> 并不是 <code class="language-plaintext highlighter-rouge">String</code>、<code class="language-plaintext highlighter-rouge">Character</code> 或 <code class="language-plaintext highlighter-rouge">UnicodeScalar</code>，不过它可以根据上下文变成这些类型，默认情况是变成 <code class="language-plaintext highlighter-rouge">String</code>。</p>

<p>因此类型在使用默认以外的字面量方式构造值，并且该类型不能通过上下文推断更多信息时，需要在声明里用显式类型，或者用 <code class="language-plaintext highlighter-rouge">as</code> 表达式来进行强制转换。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 没有更明确的类型，x1 会被推断为 Int 类型。</span>
<span class="k">let</span> <span class="nv">x1</span> <span class="o">=</span> <span class="mi">50</span>

<span class="c1">// 这些是明确的 Int32 类型。</span>
<span class="k">let</span> <span class="nv">x2</span><span class="p">:</span> <span class="kt">Int32</span> <span class="o">=</span> <span class="mi">50</span>
<span class="k">let</span> <span class="nv">x3</span> <span class="o">=</span> <span class="mi">50</span> <span class="k">as</span> <span class="kt">Int32</span>

<span class="c1">// 没有更明确的类型，y1 会被推断为 String 类型。</span>
<span class="k">let</span> <span class="nv">y1</span> <span class="o">=</span> <span class="s">"a"</span>

<span class="c1">// 这些是明确的 Character 类型。</span>
<span class="k">let</span> <span class="nv">y2</span><span class="p">:</span> <span class="kt">Character</span> <span class="o">=</span> <span class="s">"a"</span>
<span class="k">let</span> <span class="nv">y3</span> <span class="o">=</span> <span class="s">"a"</span> <span class="k">as</span> <span class="kt">Character</span>

<span class="c1">// 这些是明确的 UnicodeScalar 类型。</span>
<span class="k">let</span> <span class="nv">y4</span><span class="p">:</span> <span class="kt">UnicodeScalar</span> <span class="o">=</span> <span class="s">"a"</span>
<span class="k">let</span> <span class="nv">y5</span> <span class="o">=</span> <span class="s">"a"</span> <span class="k">as</span> <span class="kt">UnicodeScalar</span>

<span class="kd">func</span> <span class="nf">writeByte</span><span class="p">(</span><span class="n">_</span> <span class="nv">byte</span><span class="p">:</span> <span class="kt">UInt8</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// 函数实参也可以推断，所以 50 是 UInt 但不需要强制明确。</span>
<span class="nf">writeByte</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
</code></pre></div></div>

<p>如果字面量的强制转换不合理，编译器会抛出对应的错误，例如，将不是整数的数字转换成整数，或者将一个字符串转换成字符。所以下面例子抛出错误是“好”事，因为这些错误在编译期就找到了正确的原因。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 错误：整型字面量 ‘9223372036854775808’ 存储为 ‘Int64’ 里会溢出</span>
<span class="k">let</span> <span class="nv">a</span> <span class="o">=</span> <span class="mh">0x8000_0000_0000_0000</span> <span class="k">as</span> <span class="kt">Int64</span>

<span class="c1">// 错误：无法将“String”类型的值强制转换为“Character”</span>
<span class="k">let</span> <span class="nv">b</span> <span class="o">=</span> <span class="s">"ab"</span> <span class="k">as</span> <span class="kt">Character</span>
</code></pre></div></div>

<p>如果使用构造器语法对这些类型进行强制转换，会产生易误导的编译器错误，也可能更糟，产生难调试的运行时错误。</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 这里首先尝试通过字面量创建一个 `Int`(有符号的)，然后转换为 `UInt64`。尽管这个字面量能存入 `UInt64`，</span>
<span class="c1">// 但它在第一步无法存入 `Int`，所以这里无法通过编译。</span>
<span class="k">let</span> <span class="nv">a1</span> <span class="o">=</span> <span class="kt">UInt64</span><span class="p">(</span><span class="mh">0x8000_0000_0000_0000</span><span class="p">)</span>

<span class="c1">// 这里调用 `Character.init(_: String)`，因此会在运行时创建一个 `String` 的“a”（会涉及到耗时的堆分配），</span>
<span class="c1">// 从中提取字符，然后再释放掉它。这比恰当的强制指定耗时明显。</span>
<span class="k">let</span> <span class="nv">b</span> <span class="o">=</span> <span class="kt">Character</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span>

<span class="c1">// 和上面类似，这里会创建一个 `String` 并且使用 `Character.init(_: String)` 尝试从中提取单个字符。</span>
<span class="c1">// 这会因此先决条件在运行时发生错误。</span>
<span class="k">let</span> <span class="nv">c</span> <span class="o">=</span> <span class="kt">Character</span><span class="p">(</span><span class="s">"ab"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="playground-字面量">Playground 字面量</h3>

<p>禁止在非 playground 的代码中使用会进行图形渲染的 playground 字面量：<code class="language-plaintext highlighter-rouge">#colorLiteral(...)</code>、<code class="language-plaintext highlighter-rouge">#imageLiteral(...)</code> 和 <code class="language-plaintext highlighter-rouge">#fileLiteral(...)</code>。它们只允许出现在 playground 源码里。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">color</span> <span class="o">=</span> <span class="kt">UIColor</span><span class="p">(</span><span class="nv">red</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">green</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">blue</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">alpha</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">color</span> <span class="o">=</span> <span class="err">#</span><span class="nf">colorLiteral</span><span class="p">(</span><span class="nv">red</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">green</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">blue</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">alpha</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="捕获-vs-溢出">捕获 vs 溢出</h3>

<p>标准（捕获溢出）运算和二元运算符（<code class="language-plaintext highlighter-rouge">+</code>、<code class="language-plaintext highlighter-rouge">-</code>、<code class="language-plaintext highlighter-rouge">*</code>、<code class="language-plaintext highlighter-rouge">&lt;&lt;</code> 和 <code class="language-plaintext highlighter-rouge">&gt;&gt;</code>）大部分用于普通操作，而非掩码操作（前置 <code class="language-plaintext highlighter-rouge">&amp;</code>）。捕获溢出会更加安全，因为它防止错误数据被传递到系统的其他层级。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 推荐。溢出不会导致 balance 为负。</span>
<span class="k">let</span> <span class="nv">newBankBalance</span> <span class="o">=</span> <span class="n">oldBankBalance</span> <span class="o">+</span> <span class="n">recentHugeProfit</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 不推荐。如果加数太大，溢出会导致 balance 为负。</span>
<span class="k">let</span> <span class="nv">newBankBalance</span> <span class="o">=</span> <span class="n">oldBankBalance</span> <span class="o">&amp;+</span> <span class="n">recentHugeProfit</span>
</code></pre></div></div>

<p>掩码操作比较少见，但在模数运算的问题领域是允许的（事实上为了正确性是必要的），例如加密、大整数实现、哈希函数等等。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">hashValue</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// 推荐。这里强调的是位的分布，而非实际的数值。</span>
  <span class="k">return</span> <span class="n">foo</span><span class="o">.</span><span class="n">hashValue</span> <span class="o">&amp;+</span> <span class="mi">31</span> <span class="o">*</span> <span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">hashValue</span> <span class="o">&amp;+</span> <span class="mi">31</span> <span class="o">&amp;*</span> <span class="n">baz</span><span class="o">.</span><span class="n">hashValue</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">hashValue</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// 不正确。这可能随时出错，并且在不经意间依赖单个成员的哈希值。</span>
  <span class="k">return</span> <span class="n">foo</span><span class="o">.</span><span class="n">hashValue</span> <span class="o">+</span> <span class="mi">31</span> <span class="o">*</span> <span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">hashValue</span> <span class="o">+</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">baz</span><span class="o">.</span><span class="n">hashValue</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>掩码操作在确保值不会导致溢出（或者不需要担心溢出）的性能敏感代码里也是允许的。在这种情况下，需要使用注释来注明使用掩码操作的重要性。更进一步，在不影响性能优化的情况下，考虑增加先决调试条件来检查这些假设。</p>

<h3 id="定义新运算符">定义新运算符</h3>

<p>不理智地使用自定义运算符会显著影响代码可读性，因为比起标准库中更常用的运算符，这样的运算符缺乏共识，不容易被理解。</p>

<p>通常来说，应该避免定义自定义运算符。然而，当一个运算符在问题领域中有清晰和含义良好的定义，并且使用它会比函数调用显著提高代码的可读性时，可以使用。例如，<code class="language-plaintext highlighter-rouge">*</code> 在 Swift 里只定义为乘法运算符（不包含掩码版本）。数学矩阵库可能会定义额外的运算符来支持其他运算比如叉乘和点乘。</p>

<p>自定义 <code class="language-plaintext highlighter-rouge">&lt;~~</code> 和 <code class="language-plaintext highlighter-rouge">~~&gt;</code> 运算符来解码和编码 JSON 数据就是典型的禁止用法。这样的运算符不是 JSON 领域问题的原生处理方式，哪怕是有经验的 Swift 工程师，在没有运算符文档的情况下也可能会对这种处理代码有着不同的理解。</p>

<p>如果你必须使用第三方代码里的自定义运算符，那<strong>强烈建议</strong>你编写一个包装器，定义可读性更好的方法，作为该自定义运算符的代理。对团队新成员或者其他代码审查者来说，这会显著降低学习曲线，更快的理解代码原理。</p>

<h3 id="重载现有运算符">重载现有运算符</h3>

<p>用语义上和标准库中已存在等同的重载运算符是允许的。例子之一是实现 <code class="language-plaintext highlighter-rouge">Equatable</code> 和 <code class="language-plaintext highlighter-rouge">Hashable</code> 的运算符要求，或者定义新的 <code class="language-plaintext highlighter-rouge">Matrix</code> 类型来支持算数运算。</p>

<p>如果你希望用和原本不同的含义重载已存在的运算符，参考 <a href="#defining-new-operators">定义新运算符</a> 指引来确定是否允许。也就是说，如果新的含义在问题领域是确定已久的，并且使用该运算符会比其他语法结构提高可读性，那么就是允许的。</p>

<p>禁止更改运算符含义的一种例子是重载 <code class="language-plaintext highlighter-rouge">*</code> 和 <code class="language-plaintext highlighter-rouge">+</code> 来构建特定正则表达式的 API。相比简单的用字符串表示整个正则表达式，这样的 API 并没有提高可读性。</p>

<h2 id="文档注释">文档注释</h2>

<h3 id="通常格式">通常格式</h3>

<p>文档注释使用每行前面三个斜杠（<code class="language-plaintext highlighter-rouge">///</code>）的格式。Java 文档风格的块状注释（<code class="language-plaintext highlighter-rouge">/** ...*/</code>）是不允许的。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Returns the numeric value of the given digit represented as a Unicode scalar.</span>
<span class="c1">///</span>
<span class="c1">/// - Parameters:</span>
<span class="c1">///   - digit: The Unicode scalar whose numeric value should be returned.</span>
<span class="c1">///   - radix: The radix, between 2 and 36, used to compute the numeric value.</span>
<span class="c1">/// - Returns: The numeric value of the scalar.</span>
<span class="kd">func</span> <span class="nf">numericValue</span><span class="p">(</span><span class="n">of</span> <span class="nv">digit</span><span class="p">:</span> <span class="kt">UnicodeScalar</span><span class="p">,</span> <span class="nv">radix</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Returns the numeric value of the given digit represented as a Unicode scalar.
 *
 * - Parameters:
 *   - digit: The Unicode scalar whose numeric value should be returned.
 *   - radix: The radix, between 2 and 36, used to compute the numeric value.
 * - Returns: The numeric value of the scalar.
 */</span>
<span class="kd">func</span> <span class="nf">numericValue</span><span class="p">(</span><span class="n">of</span> <span class="nv">digit</span><span class="p">:</span> <span class="kt">UnicodeScalar</span><span class="p">,</span> <span class="nv">radix</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="cm">/**
Returns the numeric value of the given digit represented as a Unicode scalar.

- Parameters:
  - digit: The Unicode scalar whose numeric value should be returned.
  - radix: The radix, between 2 and 36, used to compute the numeric value.
- Returns: The numeric value of the scalar.
*/</span>
<span class="kd">func</span> <span class="nf">numericValue</span><span class="p">(</span><span class="n">of</span> <span class="nv">digit</span><span class="p">:</span> <span class="kt">UnicodeScalar</span><span class="p">,</span> <span class="nv">radix</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="一句话概括">一句话概括</h3>

<p>文档注释的开始使用简短的<strong>一句话</strong>概括来描述声明。（这句话可以跨行，但如果跨了很多行，作者应该考虑是否可以将概况简化，并将细节移到新的段落中。）</p>

<p>如果概括需要陈述更多细节，在后面添加额外的段落（每个段落用空行分隔）。</p>

<p>一句话概括不需要是完整的句子；例如，方法的概括通常写作动词短语，<strong>不需要</strong>加上“这个方法 […]”，因为这就是要表达的，写出来是多余的。类似，属性通常写作名词短语，<strong>不需要</strong>加上“这个属性是 […]”。然而无论如何，它们还是要以句号结尾。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// The background color of the view.</span>
<span class="k">var</span> <span class="nv">backgroundColor</span><span class="p">:</span> <span class="kt">UIColor</span>

<span class="c1">/// Returns the sum of the numbers in the given array.</span>
<span class="c1">///</span>
<span class="c1">/// - Parameter numbers: The numbers to sum.</span>
<span class="c1">/// - Returns: The sum of the numbers.</span>
<span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// This property is the background color of the view.</span>
<span class="k">var</span> <span class="nv">backgroundColor</span><span class="p">:</span> <span class="kt">UIColor</span>

<span class="c1">/// This method returns the sum of the numbers in the given array.</span>
<span class="c1">///</span>
<span class="c1">/// - Parameter numbers: The numbers to sum.</span>
<span class="c1">/// - Returns: The sum of the numbers.</span>
<span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="形参返回值和抛出标签">形参，返回值和抛出标签</h3>

<p>对形参，返回值和函数抛出的错误按照 <code class="language-plaintext highlighter-rouge">Parameter(s)</code>、<code class="language-plaintext highlighter-rouge">Returns</code> 和 <code class="language-plaintext highlighter-rouge">Throws</code> 标签的顺序清晰地写下文档。不要出现空白的描述。当一个描述需要换行时，续行的缩进在开始的标记连字符基础上加 2 个空格。</p>

<p>Xcode 里编写文档注释的推荐方式是将文字光标放在声明上并且按下 <strong>Command + Option + /</strong>。这会自动创建有待填充占位符的正确格式注释。</p>

<p><code class="language-plaintext highlighter-rouge">Parameter(s)</code> 和 <code class="language-plaintext highlighter-rouge">Returns</code> 标签只有当一句话简短概括中已经有完整描述时可以省略，如果还包括它们就只是重复已经说过的内容。</p>

<p><code class="language-plaintext highlighter-rouge">Parameter(s)</code>、<code class="language-plaintext highlighter-rouge">Returns</code> 和 <code class="language-plaintext highlighter-rouge">Throws</code> 标签后面跟着的内容需要以句号结尾，即使它们只是短语而不是完整的句子。</p>

<p>当方法只有单一的实参时，使用内联单数形式的 <code class="language-plaintext highlighter-rouge">Parameter</code> 标签。当方法有多个实参时，使用分组复数形式 <code class="language-plaintext highlighter-rouge">Parameters</code>，嵌套列表里用每个实参的名字作标签。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Returns the output generated by executing a command.</span>
<span class="c1">///</span>
<span class="c1">/// - Parameter command: The command to execute in the shell environment.</span>
<span class="c1">/// - Returns: A string containing the contents of the invoked process's</span>
<span class="c1">///   standard output.</span>
<span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nv">command</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">/// Returns the output generated by executing a command with the given string</span>
<span class="c1">/// used as standard input.</span>
<span class="c1">///</span>
<span class="c1">/// - Parameters:</span>
<span class="c1">///   - command: The command to execute in the shell environment.</span>
<span class="c1">///   - stdin: The string to use as standard input.</span>
<span class="c1">/// - Returns: A string containing the contents of the invoked process's</span>
<span class="c1">///   standard output.</span>
<span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nv">command</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">stdin</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>下面的例子是错误的，因为它们对单个形参使用复数形式 <code class="language-plaintext highlighter-rouge">Parameters</code>，或者对多个形参使用单数形式 <code class="language-plaintext highlighter-rouge">Parameter</code>。</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Returns the output generated by executing a command.</span>
<span class="c1">///</span>
<span class="c1">/// - Parameters:</span>
<span class="c1">///   - command: The command to execute in the shell environment.</span>
<span class="c1">/// - Returns: A string containing the contents of the invoked process's</span>
<span class="c1">///   standard output.</span>
<span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nv">command</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">/// Returns the output generated by executing a command with the given string</span>
<span class="c1">/// used as standard input.</span>
<span class="c1">///</span>
<span class="c1">/// - Parameter command: The command to execute in the shell environment.</span>
<span class="c1">/// - Parameter stdin: The string to use as standard input.</span>
<span class="c1">/// - Returns: A string containing the contents of the invoked process's</span>
<span class="c1">///   standard output.</span>
<span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nv">command</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">stdin</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="apple-标记格式">Apple 标记格式</h3>

<p>强烈建议使用 <a href="https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/">Apple 标记格式</a> 来添加富文本到文档中。这种标记有助于区分注释里的特征引用（例如形参名字）和描述性文本，并且可以被 Xcode 和其他文档生成工具渲染。下面列出一些常用指令的示例。</p>

<ul>
  <li>段落以 <code class="language-plaintext highlighter-rouge">///</code> 开始的单一空白行分隔。</li>
  <li>以<em>*单星号*</em>和<em>_单下划线_</em>包围的文本会被渲染成斜体/斜型。</li>
  <li>以<strong>**双星号**</strong>和<strong>__双下划线__</strong>包围的文本会被渲染成粗体。</li>
  <li>符号名或者内联代码以 <code class="language-plaintext highlighter-rouge">`反引号`</code>包围。</li>
  <li>多行代码（例如作为用例）以三个反引号（<code class="language-plaintext highlighter-rouge"> </code>``  `）的行开头和结束。</li>
</ul>

<h3 id="注释的位置">注释的位置</h3>

<p>最起码，每个 open 或 public 声明和里面的每个 open 或 public 成员都应该有文档注释，除了下面的情况：</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">enum</code> 里单个的枚举项名字如果已经可以自解释，则通常不需要注释。有关联值的枚举项如果值的含义不明确，那么不管怎样都应该注释。</p>
  </li>
  <li>
    <p>覆盖父类的声明、协议要求的实现或者提供协议要求的默认实现的扩展声明。</p>

    <p>覆盖声明可以添加注释来描述新行为。但是任何情况下都不应该单纯拷贝基类的声明文档。</p>
  </li>
  <li>
    <p>测试类和测试方法可以不需要文档注释。然而，注释对于在多个测试里复用的函数式测试类和帮助类/方法时是有帮助的。</p>
  </li>
  <li>
    <p>扩展声明（也就是自身的 <code class="language-plaintext highlighter-rouge">extension</code>）可以不需要文档注释。如果能帮助明确拓展的用途，你可以选择添加，但避免无意义或者误导的注释。</p>

    <p>在下面的例子中，注释仅仅重复了源码显而易见的事：</p>

    <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Add `Equatable` conformance.</span>
<span class="kd">extension</span> <span class="kt">MyType</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>下面的例子更微妙一些，但这是一个注释无法拓展的例子，因为这个拓展或者类型一致性在以后可能会变化。这个 <code class="language-plaintext highlighter-rouge">Comparable</code> 可能是在编写对该类型值的排序代码时加上的，但这不是一致性的唯一可能用途，并且使用者可能在以后其他用途代码里会依赖它。</p>

    <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Make `Candidate` comparable so that they can be sorted.</span>
<span class="kd">extension</span> <span class="kt">Candidate</span><span class="p">:</span> <span class="kt">Comparable</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>通常来说，如果你发现你写的注释只是简单地重复源码中显而易见的事，并用类似”用于表示”的词语进行美化，那么将这些注释完全去掉。</p>

<p>但是，<em>不</em>要用这个例外来证明可以省略某些正常读者可能需要的相关信息。例如，对于 <code class="language-plaintext highlighter-rouge">canonicalName</code> 名字的属性，不要省略注释（只有合理的时候才可以只写 <code class="language-plaintext highlighter-rouge">/// The canonical name.</code>），因为正常读者可能不知道术语“规范名字”在上下文中的含义。 使用注释是定义该术语的好机会。</p>

</article>

  </main>

  <script type="text/javascript">
    // add JS codes here, if needed
  </script>
  <a style="position: absolute; right: 0; top: 0;" href="https://github.com/SwiftGGTeam/google-swift-style-guide-in-chinese"><img width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>



</body>

</html>
