<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Swift 编码规范</title>
    <meta name="description" content="Google's Swift style guide.
">

    <link rel="stylesheet" href="./css/main.css">
    <link rel="canonical" href="http://localhost:4000/swift-style/">
    <link rel="alternate" type="application/rss+xml" title="Google Swift Style Guide 中文版"
        href="http://localhost:4000/swift-style/feed.xml">

    <style>
        .fixed-catalog {
            position: fixed;
            height: 96vh;
            overflow-y: auto;
            left: 10px;
            top: 00px;
        }
    </style>
</head>


<body>

    <main role="main">
        <article class="page" id="contentPage">
            <header>
                <h1>Swift 编码规范</h1>
            </header>
            <!--  -->
            <style>
                article pre {
                    overflow: visible;
                }
            </style>

            <p><a href="https://google.github.io/swift/">英文原版</a></p>
            <p><a href="https://pages.swift.gg/google-swift-style-guide-in-chinese/">中文原版</a></p>

            <ul class="no_toc" id="markdown-toc">
                <li><a href="#目录" id="markdown-toc-目录">目录</a></li>
                <li><a href="#源文件的基础要求" id="markdown-toc-源文件的基础要求">源文件的基础要求</a>
                    <ul>
                        <li><a href="#文件名" id="markdown-toc-文件名">文件名</a></li>
                        <li><a href="#文件编码" id="markdown-toc-文件编码">文件编码</a></li>
                        <li><a href="#空白符" id="markdown-toc-空白符">*空白符</a></li>
                        <li><a href="#特殊转义字符" id="markdown-toc-特殊转义字符">特殊转义字符</a></li>
                    </ul>
                </li>
                <li><a href="#源文件结构" id="markdown-toc-源文件结构">源文件结构</a>
                    <ul>
                        <li><a href="#文件注释" id="markdown-toc-文件注释">文件注释</a></li>
                        <li><a href="#导入语句" id="markdown-toc-导入语句">*导入语句</a></li>
                        <li><a href="#类型变量和函数声明" id="markdown-toc-类型变量和函数声明">类型，变量和函数声明</a></li>
                        <li><a href="#声明重载" id="markdown-toc-声明重载">声明重载</a></li>
                        <li><a href="#扩展" id="markdown-toc-扩展">*扩展</a></li>
                    </ul>
                </li>
                <li><a href="#常规格式" id="markdown-toc-常规格式">常规格式</a>
                    <ul>
                        <li><a href="#单行字符限制" id="markdown-toc-单行字符限制">单行字符限制</a></li>
                        <li><a href="#花括号" id="markdown-toc-花括号">*花括号</a></li>
                        <li><a href="#分号" id="markdown-toc-分号">*分号</a></li>
                        <li><a href="#每行一个语句" id="markdown-toc-每行一个语句">*每行一个语句</a></li>
                        <li><a href="#换行" id="markdown-toc-换行">*换行</a>
                            <ul>
                                <li><a href="#函数声明" id="markdown-toc-函数声明">函数声明</a></li>
                                <li><a href="#函数调用" id="markdown-toc-函数调用">函数调用</a></li>
                                <li><a href="#控制流语句" id="markdown-toc-控制流语句">控制流语句</a></li>
                            </ul>
                        </li>
                        <li><a href="#水平空格" id="markdown-toc-水平空格">**水平空格</a></li>
                        <li><a href="#水平对齐" id="markdown-toc-水平对齐">**水平对齐</a></li>
                        <li><a href="#垂直空行" id="markdown-toc-垂直空行">垂直空行</a></li>
                        <li><a href="#括号" id="markdown-toc-括号">**括号</a></li>
                    </ul>
                </li>
                <li><a href="#特定结构格式化" id="markdown-toc-特定结构格式化">特定结构格式化</a>
                    <ul>
                        <li><a href="#非文档注释" id="markdown-toc-非文档注释">非文档注释</a></li>
                        <li><a href="#属性" id="markdown-toc-属性">*属性</a></li>
                        <li><a href="#switch-语句" id="markdown-toc-switch-语句">**Switch 语句</a></li>
                        <li><a href="#枚举项" id="markdown-toc-枚举项">枚举项</a></li>
                        <li><a href="#末尾逗号" id="markdown-toc-末尾逗号">*末尾逗号</a></li>
                        <li><a href="#注解" id="markdown-toc-注解">*注解</a></li>
                    </ul>
                </li>
                <li><a href="#命名" id="markdown-toc-命名">命名</a>
                    <ul>
                        <li><a href="#apple-api-代码风格指南" id="markdown-toc-apple-api-代码风格指南">Apple API 代码风格指南</a></li>
                        <li><a href="#命名约定不是访问控制" id="markdown-toc-命名约定不是访问控制">**访问控制</a></li>
                        <li><a href="#构造器" id="markdown-toc-构造器">*构造器</a></li>
                        <li><a href="#静态属性和类属性" id="markdown-toc-静态属性和类属性">*静态属性和类属性</a></li>
                        <li><a href="#全局常量" id="markdown-toc-全局常量">*全局常量</a></li>
                        <li><a href="#代理方法" id="markdown-toc-代理方法">*代理方法</a></li>
                    </ul>
                </li>
                <li><a href="#编程实践" id="markdown-toc-编程实践">编程实践</a>
                    <ul>
                        <li><a href="#编译器警告" id="markdown-toc-编译器警告">**编译器警告</a></li>
                        <li><a href="#构造器-1" id="markdown-toc-构造器-1">*构造器</a></li>
                        <li><a href="#属性-1" id="markdown-toc-属性-1">*属性</a></li>
                        <li><a href="#类型简称" id="markdown-toc-类型简称">*类型简称</a></li>
                        <li><a href="#可选类型" id="markdown-toc-可选类型">可选类型</a></li>
                        <li><a href="#强制解包和强制类型转换" id="markdown-toc-强制解包和强制类型转换">强制解包和强制类型转换</a></li>
                        <li><a href="#可选值隐式解包" id="markdown-toc-可选值隐式解包">可选值隐式解包</a></li>
                        <li><a href="#访问等级" id="markdown-toc-访问等级">**访问等级</a></li>
                        <li><a href="#嵌套和命名空间" id="markdown-toc-嵌套和命名空间">*嵌套和命名空间</a></li>
                        <li><a href="#提前退出的-guard" id="markdown-toc-提前退出的-guard">提前退出的 <code
                                    class="language-plaintext highlighter-rouge">guard</code></a></li>
                        <li><a href="#在-switch-语句里的-fallthrough" id="markdown-toc-在-switch-语句里的-fallthrough">在 <code
                                    class="language-plaintext highlighter-rouge">switch</code> 语句里的 <code
                                    class="language-plaintext highlighter-rouge">fallthrough</code></a></li>
                        <li><a href="#数字和字符串字面量" id="markdown-toc-数字和字符串字面量">数字和字符串字面量</a></li>
                        <li><a href="#playground-字面量" id="markdown-toc-playground-字面量">Playground 字面量</a></li>
                        <li><a href="#定义新运算符" id="markdown-toc-定义新运算符">*定义新运算符</a></li>
                        <li><a href="#重载现有运算符" id="markdown-toc-重载现有运算符">重载现有运算符</a></li>
                    </ul>
                </li>
                <li><a href="#文档注释" id="markdown-toc-文档注释">*文档注释</a>
                    <ul>
                        <li><a href="#通常格式" id="markdown-toc-通常格式">通常格式</a></li>
                        <li><a href="#一句话概括" id="markdown-toc-一句话概括">一句话概括</a></li>
                        <li><a href="#形参返回值和抛出标签" id="markdown-toc-形参返回值和抛出标签">形参，返回值和抛出标签</a></li>
                        <li><a href="#apple-标记格式" id="markdown-toc-apple-标记格式">Apple 标记格式</a></li>
                        <li><a href="#注释的位置" id="markdown-toc-注释的位置">注释的位置</a></li>
                    </ul>
                </li>
            </ul>
            <h2 id="源文件的基础要求">源文件的基础要求</h2>

            <h3 id="文件名">文件名</h3>

            <p>所有 Swift 源文件以扩展名 <code class="language-plaintext highlighter-rouge">.swift</code> 结尾。</p>

            <p><strong>禁止使用拼音或拼音缩写命名文件和变量。</strong></p>

            <p>通常来说，源文件的名字最好描述包含的主要内容。如果文件主要包含单个类型，则用类型名命名文件。如果文件是为已存在类型添加新的协议遵循，则命名为类名和协议名的组合，通过加号（+）连接。对于更复杂的情况，最好由你自己判断。
            </p>

            <p>例如，</p>

            <ul>
                <li>文件中包含单个类型 <code class="language-plaintext highlighter-rouge">MyType</code>，命名为 <code
                        class="language-plaintext highlighter-rouge">MyType.swift</code>。</li>
                <li>文件中包含类型 <code class="language-plaintext highlighter-rouge">MyType</code> 和一些顶层的工具函数，也命名为 <code
                        class="language-plaintext highlighter-rouge">MyType.swift</code>。（顶层的工具函数不是主要的内容。）</li>
                <li>文件中包含单个扩展，为类型 <code class="language-plaintext highlighter-rouge">MyType</code> 添加 <code
                        class="language-plaintext highlighter-rouge">MyProtocol</code> 协议遵循，命名为 <code
                        class="language-plaintext highlighter-rouge">MyType+MyProtocol.swift</code>。</li>
                <li>文件中包含多个扩展，为类型 <code class="language-plaintext highlighter-rouge">MyType</code>
                    添加协议遵循、嵌套类型或者其他功能的拓展，可以使用更通用的命名，只要它的前缀是 <code
                        class="language-plaintext highlighter-rouge">MyType+</code>；例如，<code
                        class="language-plaintext highlighter-rouge">MyType+Additions.swift</code>。</li>
                <li>文件中包含多个在公共类型或命名空间下没有作用域限制的相关声明（比如一系列全局的数学函数），可以命名得更有描述性。例如：<code
                        class="language-plaintext highlighter-rouge">Math.swift</code>。</li>
            </ul>

            <h3 id="文件编码">文件编码</h3>

            <p>源文件以 UTF-8 方式编码。</p>

            <h3 id="空白符">空白符</h3>

            <p>除了行终止符之外，Unicode 水平空格符（<code
                    class="language-plaintext highlighter-rouge">U+0020</code>）是唯一可以出现在源文件里的空白符。这意味着：</p>

            <ul>
                <li>字符串或者字符字面量里的所有其他空白符，要用对应的转义字符表示。</li>
                <li>制表符不用于缩进。<strong>缩进使用4个水平空格符</strong></li>
                <li>xcode 设置缩进样式：</li>
                <img src="./xcode设置缩进.png" alt="">
            </ul>

            <h3 id="特殊转义字符">特殊转义字符</h3>

            <p>任何字符中如果包含了特殊转义字符（<code class="language-plaintext highlighter-rouge">\t</code>、<code
                    class="language-plaintext highlighter-rouge">\n</code>、<code
                    class="language-plaintext highlighter-rouge">\r</code>、<code
                    class="language-plaintext highlighter-rouge">\"</code>、<code
                    class="language-plaintext highlighter-rouge">\'</code>、<code
                    class="language-plaintext highlighter-rouge">\\</code> 和 <code
                    class="language-plaintext highlighter-rouge">\0</code>），直接使用该转义字符，不用其等价的 Unicode 转义字符（例如：<code
                    class="language-plaintext highlighter-rouge">\u{000a}</code>）。</p>

            <h2 id="源文件结构">源文件结构</h2>

            <h3 id="文件注释">文件注释</h3>

            <p>描述源文件内容的注释是可选的。对只包含了单一抽象（例如一个类的声明）的文件并不建议用这种注释——这种情况下，抽象本身的文档注释就足够了，文件注释只有当提供了额外的有用信息时才需要。如果文件中包含多个抽象，可以添加文件注释，对整体内容进行解释。
            </p>

            <h3 id="导入语句">导入语句</h3>

            <p>源文件中应该显式导入需要的顶层模块；不要多也不要少。如果源文件中同时使用了 <code class="language-plaintext highlighter-rouge">UIKit</code>
                中的定义和 <code class="language-plaintext highlighter-rouge">Foundation</code> 中的定义，那么都进行显式导入；即使有些 Apple
                框架已经在实现细节中导入其他框架。</p>

            <p>优先考虑导入整个模块，而非导入单个声明或者子模块。</p>

            <blockquote>
                <p>避免导入单个成员的原因如下：</p>

                <ul>
                    <li>没有自动化工具来解决/组织那些导入。</li>
                    <li>现存地自动化工具（例如 Xcode 迁移器）很可能无法处理导入单个成员的代码，因为这不是常见用法。</li>
                    <li>目前流行的 Swift 代码风格（基于官方例子和社区代码）都是导入整个模块。</li>
                </ul>
            </blockquote>

            <p>如果导入完整模块的顶层定义（例如 C 接口）会污染全局命名空间，那导入单个声明是允许的。在这些情况下，由你自己判断应该如何导入。</p>

            <p>如果子模块的导出功能在只导入顶层模块时不可用，那么允许导入子模块。例如：<code
                    class="language-plaintext highlighter-rouge">UIKit.UIGestureRecognizerSubclass</code> 必须要显式导入，以暴露继承
                <code class="language-plaintext highlighter-rouge">UIGestureRecognizer</code> 时代码允许重写的方法——这在只导入 <code
                    class="language-plaintext highlighter-rouge">UIKit</code> 时并不可见。
            </p>

            <p>导入语句不可换行。</p>

            <p>在源文件中，导入语句放在除了注释以外的最前面。按以下方式分组，每组中的导入按照字母顺序排序，每组之间只有一个空行：</p>

            <ol>
                <li>
                    <p>无测试模块/子模块的导入</p>
                </li>
                <li>
                    <p>单个声明的导入 (<code class="language-plaintext highlighter-rouge">class</code>、<code
                            class="language-plaintext highlighter-rouge">enum</code>、<code
                            class="language-plaintext highlighter-rouge">func</code>、<code
                            class="language-plaintext highlighter-rouge">struct</code>、<code
                            class="language-plaintext highlighter-rouge">var</code>)</p>
                </li>
                <li>
                    <p><code class="language-plaintext highlighter-rouge">@testable</code> 模块的导入（只存在测试源码中）</p>
                </li>
            </ol>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">import</span> <span class="kt">CoreLocation</span>
  <span class="kd">import</span> <span class="kt">MyThirdPartyModule</span>
  <span class="kd">import</span> <span class="kt">SpriteKit</span>
  <span class="kd">import</span> <span class="kt">UIKit</span>
  
  <span class="kd">import</span> <span class="kd">func</span> <span class="kt">Darwin</span><span class="o">.</span><span class="kt">C</span><span class="o">.</span><span class="n">isatty</span>
  
  <span class="kd">@testable</span> <span class="kd">import</span> <span class="kt">MyModuleUnderTest</span>
  </code></pre>
                </div>
            </div>

            <h3 id="类型变量和函数声明">类型，变量和函数声明</h3>

            <p>通常情况下，大部分源文件只包含一个顶层类型，特别是类型声明很庞大时。除非在同一文件里包含多个相关类型是有意义的。例如，</p>

            <ul>
                <li>
                    <p>类和它的代理协议可以定义在同一文件中。</p>
                </li>
                <li>
                    <p>类型和它相关的轻量帮助类型可以定义在同一文件中。这种时候需要使用 <code
                            class="language-plaintext highlighter-rouge">fileprivate</code>
                        将类型和/或它帮助类的某些功能限制在那个文件中而非暴露给模块的其他地方。</p>
                </li>
            </ul>

            <p>在源文件中类型、变量和函数之间的顺序，和该类型成员的顺序，都会大大影响可读性。然而，如何组织它们并没有单一正确的法则；不同的文件和不同的类型可以用不同的方式组织它们内容的排序。</p>

            <p>重要的是，每一个文件和类型使用<strong><em>同一</em></strong><em>排序逻辑</em>
                ，并且维护者应该可以解释清楚这个逻辑。例如，新的方法不能习惯性地加在类型的最后面，因为这只是顺从“日期递增地时间排序”，而不是有逻辑性的排序。</p>

            <p>当决定成员的排序逻辑后，使用 <code class="language-plaintext highlighter-rouge">// MARK:</code>
                注释对该分组提供描述，对阅读者和将来的编码者（包括你自己）是很有帮助的。这种注释也会被 Xcode 理解并在源码窗口的导航栏中提供书签。（类似的还有 <code
                    class="language-plaintext highlighter-rouge">// MARK: -</code>，在描述之前使用一个连字符的话， Xcode
                会在菜单元素前插入一条分隔线。）例如，</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">class</span> <span class="kt">MovieRatingViewController</span><span class="p">:</span> <span class="kt">UITableViewController</span> <span class="p">{</span>
  
    <span class="c1">// MARK: - View controller lifecycle methods</span>
  
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// ...</span>
    <span class="p">}</span>
  
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewWillAppear</span><span class="p">(</span><span class="n">_</span> <span class="nv">animated</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// ...</span>
    <span class="p">}</span>
  
    <span class="c1">// MARK: - Movie rating manipulation methods</span>
  
    <span class="kd">@objc</span> <span class="kd">private</span> <span class="kd">func</span> <span class="nf">ratingStarWasTapped</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UIButton</span><span class="p">?)</span> <span class="p">{</span>
      <span class="c1">// ...</span>
    <span class="p">}</span>
  
    <span class="kd">@objc</span> <span class="kd">private</span> <span class="kd">func</span> <span class="nf">criticReviewWasTapped</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UIButton</span><span class="p">?)</span> <span class="p">{</span>
      <span class="c1">// ...</span>
    <span class="p">}</span>
  <span class="p">}</span>
  </code></pre>
                </div>
            </div>

            <h3 id="声明重载">声明重载</h3>

            <p>当一个类型有多个构造器或者下标，或者一个文件/类型内有多个相同名字的函数（尽管可能有不同的实参标签），<em>并且</em>当这些重载在同一类型或者扩展作用域内时，它们应该按顺序排列，不应该在中间插入其他代码。
            </p>

            <h3 id="扩展">扩展</h3>

            <p>扩展可以将一个类型的功能组织到多个“单元”中。配合成员排序和所选择的组织结构/分组，会对代码可读性有很大的帮助；你必须使用<strong><em>某种</em></strong>能给审查者解释的<em>逻辑结构</em>进行组织。
            </p>

            <h2 id="常规格式">常规格式</h2>

            <h3 id="单行字符限制">单行字符限制</h3>

            <p>Swift 代码有 100 字符单行限制。除了下面的说明之外，任何超过该限制的行都需要换行，详情见 <a href="#line-wrapping">换行</a>。</p>

            <p><strong>例外：</strong></p>

            <ol>
                <li>
                    <p>即便是遵循单行字符限制的行，也不应该破坏文本中有意义的部分（例如，注释里的长 URL ）。</p>
                </li>
                <li>
                    <p><code class="language-plaintext highlighter-rouge">import</code> 语句。</p>
                </li>
                <li>
                    <p>其他工具生成的代码。</p>
                </li>
            </ol>

            <h3 id="花括号">花括号</h3>

            <p>通常来说，内容非空的花括号遵循 Kernighan 和 Ritchie（K&amp;R）代码风格，除了 Swift 特殊结构和规则以外：</p>

            <ul>
                <li>
                    <p>左花括号（<code
                            class="language-plaintext highlighter-rouge">{</code>）之前<strong>不需要</strong>换行，<strong>除非</strong>是为了满足
                        <a href="#line-wrapping">换行</a> 规则。
                    </p>
                </li>
                <li>
                    <p>左花括号（<code
                            class="language-plaintext highlighter-rouge">{</code>）之后<strong>需要</strong>换行，除非满足下面的条件</p>

                    <ul>
                        <li>
                            <p>在闭包中，如果长度足够，将闭包的签名和花括号在同一行，在 <code class="language-plaintext highlighter-rouge">in</code>
                                关键字后面换行。</p>
                        </li>
                        <li>
                            <p>可以省略成 <a href="#one-statement-per-line">单行语句</a>。</p>
                        </li>
                        <li>
                            <p>空白块应该写作 <code class="language-plaintext highlighter-rouge">{}</code>。</p>
                        </li>
                    </ul>
                </li>
                <li>
                    <p>右花括号（<code class="language-plaintext highlighter-rouge">}</code>）之前<strong>需要</strong>换行，除非可以省略成
                        <a href="#one-statement-per-line">单行语句</a> 或是空白块。
                    </p>
                </li>
                <li>
                    <p>右花括号（<code
                            class="language-plaintext highlighter-rouge">}</code>）之后<strong>需要</strong>换行的情况，<strong>有且仅当</strong>该花括号用作终止语句或者作为声明体。例如，<code
                            class="language-plaintext highlighter-rouge">else</code> 块写成 <code
                            class="language-plaintext highlighter-rouge">} else {</code> 时两个花括号在同一行。</p>
                </li>
            </ul>

            <h3 id="分号">分号</h3>

            <p>分号（<code class="language-plaintext highlighter-rouge">;</code>）<strong>禁止使用</strong>，无论是用于终止或者分割语句。</p>

            <p>换而言之，分号只可能出现在字符串字面量或者注释中。</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">func</span> <span class="nf">printSum</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span>
  <span class="p">}</span>
  </code></pre>
                </div>
            </div>

            <div class="language-swift bad highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">func</span> <span class="nf">printSum</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
  <span class="p">}</span>
  </code></pre>
                </div>
            </div>

            <h3 id="每行一个语句">每行一个语句</h3>

            <p>每行<strong>最多</strong>一个语句，每个语句后换行，除非该行结尾的块中只有 0 或者 1 条语句。</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">guard</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="n">value</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>
  
  <span class="k">defer</span> <span class="p">{</span> <span class="n">file</span><span class="o">.</span><span class="nf">close</span><span class="p">()</span> <span class="p">}</span>
  
  <span class="k">switch</span> <span class="n">someEnum</span> <span class="p">{</span>
  <span class="k">case</span> <span class="o">.</span><span class="nv">first</span><span class="p">:</span> <span class="k">return</span> <span class="mi">5</span>
  <span class="k">case</span> <span class="o">.</span><span class="nv">second</span><span class="p">:</span> <span class="k">return</span> <span class="mi">10</span>
  <span class="k">case</span> <span class="o">.</span><span class="nv">third</span><span class="p">:</span> <span class="k">return</span> <span class="mi">20</span>
  <span class="p">}</span>
  
  <span class="k">let</span> <span class="nv">squares</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="p">}</span>
  
  <span class="k">var</span> <span class="nv">someProperty</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">otherObject</span><span class="o">.</span><span class="n">property</span> <span class="p">}</span>
    <span class="k">set</span> <span class="p">{</span> <span class="n">otherObject</span><span class="o">.</span><span class="n">property</span> <span class="o">=</span> <span class="n">newValue</span> <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="k">var</span> <span class="nv">someProperty</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">otherObject</span><span class="o">.</span><span class="nf">somethingElse</span><span class="p">()</span> <span class="p">}</span>
  
  <span class="kd">required</span> <span class="nf">init</span><span class="p">?(</span><span class="n">coder</span> <span class="nv">aDecoder</span><span class="p">:</span> <span class="kt">NSCoder</span><span class="p">)</span> <span class="p">{</span> <span class="nf">fatalError</span><span class="p">(</span><span class="s">"no coder"</span><span class="p">)</span> <span class="p">}</span>
  </code></pre>
                </div>
            </div>

            <p>将块里包含的单个语句和块放在同一行总是允许的。由你自己判断是否将条件语句和它的执行体放在同一行中。例如，单行条件适合跟提前返回并进行简单收尾的代码放在一行，但是当执行体里包含了函数调用或者重要的逻辑就不太合适。如果不确定哪种更好，使用多行语句。
            </p>

            <h3 id="换行">换行</h3>

            <blockquote>
                <p>术语说明：<strong>换行</strong>是将代码分割到多个行的行为，否则它们都会堆积到同一行。</p>
            </blockquote>


            <h4 id="函数声明">函数声明</h4>

            <p>多个参数</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">public</span> <span class="kd">func</span> <span class="n">index</span><span class="o">&lt;</span><span class="kt">Elements</span><span class="p">:</span> <span class="kt">Collection</span><span class="p">,</span> <span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">of</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span>
    <span class="k">in</span> <span class="nv">collection</span><span class="p">:</span> <span class="kt">Elements</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Elements</span><span class="o">.</span><span class="kt">Index</span><span class="p">?</span> <span class="k">where</span> <span class="kt">Elements</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Element</span><span class="p">,</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">current</span> <span class="k">in</span> <span class="n">elements</span> <span class="p">{</span>
      <span class="c1">// ...</span>
    <span class="p">}</span>
  <span class="p">}</span>
  </code></pre>
                </div>
            </div>

            <p>协议里以右括号（<code
                    class="language-plaintext highlighter-rouge">)</code>）结束的函数声明可以将括号和最后的实参放在同一行<strong>或者</strong>另起一行。
            </p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">ContrivedExampleDelegate</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">contrivedExample</span><span class="p">(</span>
      <span class="n">_</span> <span class="nv">contrivedExample</span><span class="p">:</span> <span class="kt">ContrivedExample</span><span class="p">,</span>
      <span class="n">willDoSomethingTo</span> <span class="nv">someValue</span><span class="p">:</span> <span class="kt">SomeValue</span><span class="p">)</span>
  <span class="p">}</span>

  </code></pre>
                </div>
            </div>

            <p>用 <code class="language-plaintext highlighter-rouge">typealias</code> 或其他手段简化复杂声明通常是更好的解决方法。</p>


            <h4 id="函数调用">函数调用</h4>

            <p>当函数调用需要换行时，每一个实参单独一行，并在原始行缩进基础上 +2。</p>

            <p>和函数声明一样，如果函数调用的语句以右括号（<code
                    class="language-plaintext highlighter-rouge">)</code>）结束（意味着没有尾随闭包），括号<strong>既可以</strong>和最后一个实参在同一行<strong>也可以</strong>另起一行。
            </p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="nf">index</span><span class="p">(</span>
    <span class="nv">of</span><span class="p">:</span> <span class="n">veryLongElementVariableName</span><span class="p">,</span>
    <span class="nv">in</span><span class="p">:</span> <span class="n">aCollectionOfElementsThatAlsoHappensToHaveALongName</span><span class="p">)</span>
  </code></pre>
                </div>
            </div>

            <p>如果函数调用以尾随闭包结束，并且闭包签名需要换行的话，另起一行并将实参列表包在括号中以便和下面的闭包体区分。</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="n">someAsynchronousAction</span><span class="o">.</span><span class="nf">execute</span><span class="p">(</span><span class="nv">withDelay</span><span class="p">:</span> <span class="n">howManySeconds</span><span class="p">,</span> <span class="nv">context</span><span class="p">:</span> <span class="n">actionContext</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">completion</span><span class="p">)</span> <span class="k">in</span>
    <span class="nf">doSomething</span><span class="p">(</span><span class="nv">withContext</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span>
    <span class="nf">completion</span><span class="p">()</span>
  <span class="p">}</span>
  </code></pre>
                </div>
            </div>

            <h4 id="控制流语句">控制流语句</h4>

            <p>当控制流语句（例如 <code class="language-plaintext highlighter-rouge">if</code>、<code
                    class="language-plaintext highlighter-rouge">gurad</code>、<code
                    class="language-plaintext highlighter-rouge">while</code> 或者 <code
                    class="language-plaintext highlighter-rouge">for</code>）需要换行时，首个后续行的缩进和紧接着控制流关键字的元素保持一致。其余的后续行如果是语法上平级的元素，那么缩进也保持一致。</p>

            <p>控制流语句执行体前面的左花括号（<code
                    class="language-plaintext highlighter-rouge">{</code>），既可以和最后的条件同一行，也可以另起一行并和该语句缩进保持一致。对于 <code
                    class="language-plaintext highlighter-rouge">guard</code> 语句，<code
                    class="language-plaintext highlighter-rouge">else {</code> 必须连在一起，不管是在同一行还是另起一行。</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">if</span> <span class="nf">aBooleanValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
     <span class="nf">aDifferentBooleanValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
     <span class="nf">yetAnotherBooleanValueThatContributesToTheWrapping</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">  doSomething</span><span class="p">()</span>
  <span class="p">}</span>
  
  <span class="k">if</span> <span class="nf">aBooleanValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
     <span class="nf">aDifferentBooleanValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
     <span class="nf">yetAnotherBooleanValueThatContributesToTheWrapping</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="nf">  doSomething</span><span class="p">()</span>
  <span class="p">}</span>
  
  <span class="k">if</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="nf">aValueReturnedByAVeryLongOptionalThing</span><span class="p">(),</span>
     <span class="k">let</span> <span class="nv">value2</span> <span class="o">=</span> <span class="nf">aDifferentValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">  doSomething</span><span class="p">()</span>
  <span class="p">}</span>
  
  <span class="k">if</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="nf">aValueReturnedByAVeryLongOptionalThing</span><span class="p">(),</span>
     <span class="k">let</span> <span class="nv">value2</span> <span class="o">=</span> <span class="nf">aDifferentValueReturnedByAVeryLongOptionalThingThatForcesTheBraceToBeWrapped</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="nf">  doSomething</span><span class="p">()</span>
  <span class="p">}</span>
  
  <span class="k">guard</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="nf">aValueReturnedByAVeryLongOptionalThing</span><span class="p">(),</span>
        <span class="k">let</span> <span class="nv">value2</span> <span class="o">=</span> <span class="nf">aDifferentValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nf">  doSomething</span><span class="p">()</span>
  <span class="p">}</span>
  
  <span class="k">guard</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="nf">aValueReturnedByAVeryLongOptionalThing</span><span class="p">(),</span>
        <span class="k">let</span> <span class="nv">value2</span> <span class="o">=</span> <span class="nf">aDifferentValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="nf">  doSomething</span><span class="p">()</span>
  <span class="p">}</span>
  
  <span class="k">for</span> <span class="n">element</span> <span class="k">in</span> <span class="n">collection</span>
      <span class="k">where</span> <span class="n">element</span><span class="o">.</span><span class="n">happensToHaveAVeryLongPropertyNameThatYouNeedToCheck</span> <span class="p">{</span>
    <span class="nf">  doSomething</span><span class="p">()</span>
  <span class="p">}</span>
  </code></pre></div> </div>

<h3 id="水平空格">水平空格</h3>

<blockquote>
  <p><strong>术语说明：</strong>在这个章节，_水平空格_指的是_内部_空格。这些规则不适用于行开始时需要或禁止的额外空格。</p>
</blockquote>

<p>根据语言要求或其他代码风格的规则，除了字面量和注释外的单个 Unicode 空格<strong>只能</strong>在下面这些情况出现：</p>

<ol>
  <li>
    <p>条件或 switch 语句（例如 <code class="highlighter-rouge">if</code>、<code class="highlighter-rouge">guard</code>、<code class="highlighter-rouge">while</code> 或者 <code class="highlighter-rouge">switch</code>）开始的任何保留关键字要和它之后的表达式分隔开，如果该表达式以左括号（<code class="highlighter-rouge">(</code>）开始。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>在同一行代码后面的右花括号（<code class="highlighter-rouge">}</code>）之前，任何左花括号（<code class="highlighter-rouge">{</code>）之前，后续代码在同一行的左花括号（<code class="highlighter-rouge">{</code>）之后。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">nonNegativeCubes</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="p">}</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">nonNegativeCubes</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="p">}</span> <span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">}</span>
<span class="k">let</span> <span class="nv">nonNegativeCubes</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span><span class="p">}</span><span class="o">.</span><span class="n">filter</span><span class="p">{</span><span class="nv">$0</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>在二元或者三元运算符的每一侧，包括下面描述的“类运算符”，除了最后的例外：</p>

    <ol>
      <li>
        <p><code class="highlighter-rouge">=</code> 运算符用在赋值，变量/属性的构造过程以及函数里的默认实参时。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">x</span> <span class="o">=</span> <span class="mi">5</span>
      
<span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">],</span> <span class="nv">initialValue</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">x</span><span class="o">=</span><span class="mi">5</span>
      
<span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">],</span> <span class="nv">initialValue</span><span class="p">:</span> <span class="kt">Int</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>And 符号（<code class="highlighter-rouge">&amp;</code>）用在协议组合类型时。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">sayHappyBirthday</span><span class="p">(</span><span class="n">to</span> <span class="nv">person</span><span class="p">:</span> <span class="kt">NameProviding</span> <span class="o">&amp;</span> <span class="kt">AgeProviding</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">sayHappyBirthday</span><span class="p">(</span><span class="n">to</span> <span class="nv">person</span><span class="p">:</span> <span class="kt">NameProviding</span><span class="o">&amp;</span><span class="kt">AgeProviding</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>

        <p>运算符用在函数声明/实现时。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span> <span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">MyType</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">MyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span><span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">MyType</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">MyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>箭头（<code class="highlighter-rouge">-&gt;</code>）用在函数的返回类型之前时。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span><span class="o">-&gt;</span><span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p><strong>例外：</strong>点（<code class="highlighter-rouge">.</code>）用在引用值和类型成员时两侧都没有空格。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">width</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">width</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">width</span> <span class="o">=</span> <span class="n">view</span> <span class="o">.</span> <span class="n">bounds</span> <span class="o">.</span> <span class="n">width</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p><strong>例外：</strong><code class="highlighter-rouge">..&lt;</code> 或者 <code class="highlighter-rouge">…</code> 运算符用在范围表达式时两侧都没空格。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="mi">1</span><span class="o">...</span><span class="mi">5</span> <span class="p">{</span>
 <span class="c1">// ...</span>
<span class="p">}</span>
      
<span class="k">let</span> <span class="nv">substring</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="n">index</span><span class="o">..&lt;</span><span class="n">string</span><span class="o">.</span><span class="n">endIndex</span><span class="p">]</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="mi">1</span> <span class="o">...</span> <span class="mi">5</span> <span class="p">{</span>
 <span class="c1">// ...</span>
<span class="p">}</span>
      
<span class="k">let</span> <span class="nv">substring</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="n">index</span> <span class="o">..&lt;</span> <span class="n">string</span><span class="o">.</span><span class="n">endIndex</span><span class="p">]</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
  <li>

    <p>逗号（<code class="highlighter-rouge">,</code>）用在形参列表和元组/数组/字典字面量时，在逗号后面而不是前面。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div>    </div>

    <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="p">,</span><span class="mi">2</span> <span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="p">,</span> <span class="mi">2</span> <span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
  <li>

    <p>如果是下列场景，加在冒号（<code class="highlighter-rouge">:</code>）后面而不是前面</p>

    <ol>
      <li>
        <p>父类/协议遵循列表和范型约束。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">HashTable</span><span class="p">:</span> <span class="kt">Collection</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
      
<span class="kd">struct</span> <span class="kt">AnyEquatable</span><span class="o">&lt;</span><span class="kt">Wrapped</span><span class="p">:</span> <span class="kt">Equatable</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">HashTable</span> <span class="p">:</span> <span class="kt">Collection</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
      
<span class="kd">struct</span> <span class="kt">AnyEquatable</span><span class="o">&lt;</span><span class="kt">Wrapped</span> <span class="p">:</span> <span class="kt">Equatable</span><span class="o">&gt;</span> <span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>

        <p>函数实参标签和元组元素标签。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">tuple</span><span class="p">:</span> <span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
      
<span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">tuple</span><span class="p">:</span> <span class="p">(</span><span class="nv">x</span><span class="p">:</span><span class="kt">Int</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span><span class="kt">Int</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">tuple</span><span class="p">:</span> <span class="p">(</span><span class="nv">x</span> <span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">y</span> <span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
      
<span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:[</span><span class="kt">Int</span><span class="p">])</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
      
<span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span> <span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>变量/属性的类型显式声明。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">number</span><span class="p">:</span><span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>
<span class="k">let</span> <span class="nv">number</span> <span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>字典类型缩写。</p>
        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">nameAgeMap</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">nameAgeMap</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">var</span> <span class="nv">nameAgeMap</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span> <span class="p">:</span> <span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>字典字面量。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">nameAgeMap</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Ed"</span><span class="p">:</span> <span class="mi">40</span><span class="p">,</span> <span class="s">"Timmy"</span><span class="p">:</span> <span class="mi">9</span><span class="p">]</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">nameAgeMap</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Ed"</span><span class="p">:</span><span class="mi">40</span><span class="p">,</span> <span class="s">"Timmy"</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">nameAgeMap</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Ed"</span> <span class="p">:</span> <span class="mi">40</span><span class="p">,</span> <span class="s">"Timmy"</span> <span class="p">:</span> <span class="mi">9</span><span class="p">]</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
  <li>

    <p>行尾注释的双斜杠（<code class="highlighter-rouge">//</code>），双斜杠之前最少两个空格，之后只加一个空格。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">initialFactor</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1">// Warm up the modulator.</span>
</code></pre></div>    </div>

    <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">initialFactor</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1">//    Warm up the modulator.</span>
</code></pre></div>    </div>
  </li>
  <li>

    <p>数组、字典或元组字面量定义，加在括号外面而不是里面。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div>    </div>

    <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">]</span>
</code></pre></div>    </div>
  </li>
</ol>
            

            <h3 id="水平对齐">水平对齐</h3>

            <blockquote>
                <p><strong>术语说明：</strong><em>水平对齐</em>是一种约定，通过在代码中添加不同数量的空格，让某些元素直接显示在前面行中该类型的其他元素下面。</p>
            </blockquote>

            <p>水平对齐是禁止的，除非是明确的表格数据，此时不对齐会降低可读性。其他情况下（例如，对 <code
                    class="language-plaintext highlighter-rouge">struct</code> 或 <code
                    class="language-plaintext highlighter-rouge">class</code>
                里的存储属性声明的类型进行对齐）水平对齐会引起维护问题，因为在新的成员引入时其余所有的成员都需要重新对齐。</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">struct</span> <span class="kt">DataPoint</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">var</span> <span class="nv">primaryColor</span><span class="p">:</span> <span class="kt">UIColor</span>
  <span class="p">}</span>
  </code></pre>
                </div>
            </div>

            <div class="language-swift bad highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">struct</span> <span class="kt">DataPoint</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">value</span><span class="p">:</span>        <span class="kt">Int</span>
    <span class="k">var</span> <span class="nv">primaryColor</span><span class="p">:</span> <span class="kt">UIColor</span>
  <span class="p">}</span>
  </code></pre>
                </div>
            </div>

            <h3 id="垂直空行">垂直空行</h3>

            <p>在这些情况下使用单独的空白行：</p>

            <ol>
                <li>
                    <p>在类型中这些连续成员之间：属性、构造器、方法、枚举项、嵌套类型，<strong>除非</strong>：</p>
                    <ol>
                      <li><p>如果两个连续的存储属性，或者两个枚举项可以写在一行中，那空白行就是可选的。这时候空白行可以用来对这些声明进行<em>逻辑分组</em>。</p></li>
                      <li>不适用于前面规则，但两个属性有强关联，那之间的空白行也是可选的。例如，一个私有的存储属性和它相关的公开计算属性。</li>
                  </ol>
                </li>
                <li>
                    <p>如果用于分割代码，<strong>只在需要的时候使用</strong>，根据逻辑对代码进行分割。</p>
                </li>
                <li>
                    <p>类型的第一个成员之前，或者最后一个成员之后的空白行是<em>可选的</em>（不赞成也不反对）。</p>
                </li>
                <li>
                    <p>本文档中其他章节中明确要求的地方。</p>
                </li>
            </ol>

            <p><em>多个</em>空白行是允许的，但不是必须的（不赞成）。如果使用多个连续的空白行，那么在你的代码里应该贯彻到底。</p>

            <h3 id="括号">括号</h3>

            <p><code class="language-plaintext highlighter-rouge">if</code>、<code
                    class="language-plaintext highlighter-rouge">guard</code>、<code
                    class="language-plaintext highlighter-rouge">while</code> 或 <code
                    class="language-plaintext highlighter-rouge">switch</code> 关键字后面的顶层表达式<strong>不需要</strong>使用括号。</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"x is zero"</span><span class="p">)</span>
  <span class="p">}</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"..."</span><span class="p">)</span>
  <span class="p">}</span>
  </code></pre>
                </div>
            </div>

            <div class="language-swift bad highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"x is zero"</span><span class="p">)</span>
  <span class="p">}</span>
  
  <span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"..."</span><span class="p">)</span>
  <span class="p">}</span>
  </code></pre>
                </div>
            </div>

            <p>分组括号是可选的，只有当作者和审查者觉得没有也不会令代码容易误解，或者会让代码更容易阅读时才可以被省略。<strong>不</strong>要认为每个阅读者都能记得完整的 Swift 操作符优先级表格。</p>

            <h2 id="特定结构格式化">特定结构格式化</h2>

            <h3 id="非文档注释">非文档注释</h3>

            <p>非文档注释总是用双斜杠进行格式化（<code class="language-plaintext highlighter-rouge">//</code>），不要使用 C 风格的块格式化（<code
                    class="language-plaintext highlighter-rouge">/* ... */</code>）。</p>

            <h3 id="属性">属性</h3>

            <p>局部变量尽量声明在接近首次使用的地方，（在合理的情况下）最小化作用域。</p>

            <p>除了元组的解构，每个 <code class="language-plaintext highlighter-rouge">let</code> 或者 <code
                    class="language-plaintext highlighter-rouge">var</code> 语句（无论是属性或者局部变量）只声明一个变量。</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">var</span> <span class="nv">a</span> <span class="o">=</span> <span class="mi">5</span>
<span class="k">var</span> <span class="nv">b</span> <span class="o">=</span> <span class="mi">10</span>
  
<span class="k">let</span> <span class="p">(</span><span class="nv">quotient</span><span class="p">,</span> <span class="nv">remainder</span><span class="p">)</span> <span class="o">=</span> <span class="nf">divide</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
</code></pre>
                </div>
            </div>

            <div class="language-swift bad highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">var</span> <span class="nv">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span>
  </code></pre>
                </div>
            </div>

<h3 id="switch-语句">Switch 语句</h3>

<p>枚举项语句的缩进和它们的 switch 语句保持<em>一致</em>；枚举项块里的语句在该缩进基础上 +4 空格。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">order</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">ascending</span><span class="p">:</span> 
<span class="nf">    print</span><span class="p">(</span><span class="s">"Ascending"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">descending</span><span class="p">:</span>
<span class="nf">    print</span><span class="p">(</span><span class="s">"Descending"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">same</span><span class="p">:</span>
<span class="nf">    print</span><span class="p">(</span><span class="s">"Same"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

            <div class="language-swift bad highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">switch</span> <span class="n">order</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">ascending</span><span class="p">:</span>
      <span class="nf">print</span><span class="p">(</span><span class="s">"Ascending"</span><span class="p">)</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">descending</span><span class="p">:</span>
      <span class="nf">print</span><span class="p">(</span><span class="s">"Descending"</span><span class="p">)</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">same</span><span class="p">:</span>
      <span class="nf">print</span><span class="p">(</span><span class="s">"Same"</span><span class="p">)</span>
  <span class="p">}</span>
  </code></pre></div></div>

            <div class="language-swift bad highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">switch</span> <span class="n">order</span> <span class="p">{</span>
  <span class="k">case</span> <span class="o">.</span><span class="nv">ascending</span><span class="p">:</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Ascending"</span><span class="p">)</span>
  <span class="k">case</span> <span class="o">.</span><span class="nv">descending</span><span class="p">:</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Descending"</span><span class="p">)</span>
  <span class="k">case</span> <span class="o">.</span><span class="nv">same</span><span class="p">:</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Same"</span><span class="p">)</span>
  <span class="p">}</span>
  </code></pre></div></div>
  <p>xcode 设置 Switch 语句样式：</p>
  <img src="./xcode设置switch样式.png" alt="xcode 设置 Switch 语句样式">

  <h3 id="枚举项">枚举项</h3>
  
  <p>通常来说，一个 <code class="highlighter-rouge">enum</code> 里每行只有一个 <code class="highlighter-rouge">case</code>。逗号分隔形式只能在枚举项都没有关联值或者原始值时使用，所有枚举项都能从名字明确其含义而不需要额外的注释，就可以写在同一行。</p>
  
<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Token</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">comma</span>
    <span class="k">case</span> <span class="n">semicolon</span>
    <span class="k">case</span> <span class="n">identifier</span>
<span class="p">}</span>
  
<span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Token</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">comma</span><span class="p">,</span> <span class="n">semicolon</span><span class="p">,</span> <span class="n">identifier</span>
<span class="p">}</span>
  
<span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Token</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">comma</span>
    <span class="k">case</span> <span class="n">semicolon</span>
    <span class="k">case</span> <span class="nf">identifier</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
<span class="p">}</span></code></pre></div></div>
  
<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Token</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">comma</span><span class="p">,</span> <span class="n">semicolon</span><span class="p">,</span> <span class="nf">identifier</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
  
  <p>如果 <code class="highlighter-rouge">enum</code> 里所有枚举项都需要被声明为 <code class="highlighter-rouge">indirect</code>，那这个 <code class="highlighter-rouge">enum</code> 就声明为 <code class="highlighter-rouge">indirect</code>，单独枚举项前面的关键字可以省略。</p>
  
<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">indirect</span> <span class="kd">enum</span> <span class="kt">DependencyGraphNode</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">userDefined</span><span class="p">(</span><span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="kt">DependencyGraphNode</span><span class="p">])</span>
    <span class="k">case</span> <span class="nf">synthesized</span><span class="p">(</span><span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="kt">DependencyGraphNode</span><span class="p">])</span>
<span class="p">}</span></code></pre></div></div>
  
<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">DependencyGraphNode</span> <span class="p">{</span>
    <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">userDefined</span><span class="p">(</span><span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="kt">DependencyGraphNode</span><span class="p">])</span>
    <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">synthesized</span><span class="p">(</span><span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="kt">DependencyGraphNode</span><span class="p">])</span>
<span class="p">}</span></code></pre></div></div>

  <p>当 <code class="highlighter-rouge">enum</code> 的枚举项没有关联值时，不应该出现空的括号。</p>
  
<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">node</span><span class="p">(</span><span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">empty</span>  <span class="c1">// 推荐</span>
<span class="p">}</span></code></pre></div></div>
  
<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">node</span><span class="p">(</span><span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="p">)</span>
    <span class="k">case</span> <span class="nf">empty</span><span class="p">()</span>  <span class="c1">// 不推荐</span>
<span class="p">}</span></code></pre></div></div>
  
  <p>枚举项必须遵循一定的可解释排序逻辑。如果没有明显的排序逻辑，按照枚举项名字的首字母排序。</p>
  
  <p>在下面的例子中，枚举项根据其表示的 HTTP 状态码数字进行排序，并通过空行进行分组。</p>
  
<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">HTTPStatus</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">ok</span> <span class="o">=</span> <span class="mi">200</span>
  
    <span class="k">case</span> <span class="n">badRequest</span> <span class="o">=</span> <span class="mi">400</span>
    <span class="k">case</span> <span class="n">notAuthorized</span> <span class="o">=</span> <span class="mi">401</span>
    <span class="k">case</span> <span class="n">paymentRequired</span> <span class="o">=</span> <span class="mi">402</span>
    <span class="k">case</span> <span class="n">forbidden</span> <span class="o">=</span> <span class="mi">403</span>
    <span class="k">case</span> <span class="n">notFound</span> <span class="o">=</span> <span class="mi">404</span>
  
    <span class="k">case</span> <span class="n">internalServerError</span> <span class="o">=</span> <span class="mi">500</span>
<span class="p">}</span></code></pre></div></div>
  
  <p>同样的枚举，下面这个版本的写法可读性就差一些。尽管枚举项根据字母排序，但是却失去了对关联值含义的表达。</p>
  
<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">HTTPStatus</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">badRequest</span> <span class="o">=</span> <span class="mi">400</span>
    <span class="k">case</span> <span class="n">forbidden</span> <span class="o">=</span> <span class="mi">403</span>
    <span class="k">case</span> <span class="n">internalServerError</span> <span class="o">=</span> <span class="mi">500</span>
    <span class="k">case</span> <span class="n">notAuthorized</span> <span class="o">=</span> <span class="mi">401</span>
    <span class="k">case</span> <span class="n">notFound</span> <span class="o">=</span> <span class="mi">404</span>
    <span class="k">case</span> <span class="n">ok</span> <span class="o">=</span> <span class="mi">200</span>
    <span class="k">case</span> <span class="n">paymentRequired</span> <span class="o">=</span> <span class="mi">402</span>
<span class="p">}</span></code></pre></div></div>

            <h3 id="末尾逗号">末尾逗号</h3>

<p>当数组和字典里字面量里每个元素独占一行时，<em>需要</em>加上末尾逗号。在这些字面量后续加入新的元素时，会有更明显的区分。</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">let</span> <span class="nv">configurationKeys</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">"bufferSize"</span><span class="p">,</span>
    <span class="s">"compression"</span><span class="p">,</span>
    <span class="s">"encoding"</span><span class="p">,</span>      <span class="c1">// 推荐</span>
<span class="p">]</span></code></pre></div></div>

<div class="language-swift bad highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">let</span> <span class="nv">configurationKeys</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">"bufferSize"</span><span class="p">,</span>
    <span class="s">"compression"</span><span class="p">,</span>
    <span class="s">"encoding"</span>                   <span class="c1">// 不推荐</span>
<span class="p">]</span></code></pre></div></div>

<h3 id="注解">注解</h3>

<p>每个带参数的注解（例如 <code class="language-plaintext highlighter-rouge">@availability(…)</code> 或 <code
class="language-plaintext highlighter-rouge">@objc(…)</code>）写在其适用声明的前面单独一行，按照首字母排序，缩进和声明保持一致。</p>

<div class="language-swift good highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code><span class="kd">@available</span><span class="p">(</span><span class="n">iOS</span> <span class="mf">9.0</span><span class="p">,</span> <span class="o">*</span><span class="p">)</span>
<span class="kd">public</span> <span class="kd">func</span> <span class="nf">coolNewFeature</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></div></div>

<div class="language-swift bad highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code><span class="kd">@available</span><span class="p">(</span><span class="n">iOS</span> <span class="mf">9.0</span><span class="p">,</span> <span class="o">*</span><span class="p">)</span> <span class="kd">public</span> <span class="kd">func</span> <span class="nf">coolNewFeature</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></div></div>

<p>不带参数的注解（例如不带参数的 <code class="language-plaintext highlighter-rouge">@objc</code>、<code
                    class="language-plaintext highlighter-rouge">@IBOutlet</code> 或者 <code
                    class="language-plaintext highlighter-rouge">@NSManaged</code>）当且仅当不导致换行时，<em>可以</em>按首字母排序与声明写在同一行。如果在声明的行增加该注解后导致需要换行的话，则将注解另起一行。
</p>

<div class="language-swift good highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">MyViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    <span class="kd">@IBOutlet</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="o">!</span>
<span class="p">}</span></code></pre></div></div>

            <h2 id="命名">命名</h2>

            <h3 id="apple-api-代码风格指南">Apple API 代码风格指南</h3>

            <p>Apple 官方的 <a href="https://swift.org/documentation/api-design-guidelines/">Swift 命名和 API 代码风格指南</a>
                也是本文档的一部分，同样需要遵循，这里不再重复其内容。</p>

            <blockquote>
                <p>译者注：这份文档的中文版是 SwiftGG 的长期维护项目之一，可以在 <a
                        href="https://github.com/SketchK/the-swift-api-design-guidelines-in-chinese">这里</a> 阅读。</p>
            </blockquote>

            <h3 id="命名约定不是访问控制">使用访问控制</h3>

            <p>使用 Swift 自带的访问控制（<code class="language-plaintext highlighter-rouge">internal</code>、<code
                    class="language-plaintext highlighter-rouge">fileprivate</code> 或 <code
                    class="language-plaintext highlighter-rouge">private</code>）来达到隐藏信息的目的，不要使用命名约定（例如下划线前缀）。</p>


            <p>命名约定（例如下划线前缀）只有在声明必须用到更高的可见性来解决语言限制的罕见情况下使用——例如，类型A有一个子类需要被跨模块使用，导致此类型必须被声明为 <code
                    class="language-plaintext highlighter-rouge">public</code>，但是类型A又不想被模块外使用。</p>

<h3 id="构造器">构造器</h3>

<p>为了代码可读性，构造器实参和其直接对应的存储属性同名。在赋值的时候使用显式 <code class="language-plaintext highlighter-rouge">self.</code>
                来消除歧义。</p>

<div class="language-swift good highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code><span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Person</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="kd">public</span> <span class="k">let</span> <span class="nv">phoneNumber</span><span class="p">:</span> <span class="kt">String</span>
  
    <span class="c1">// 推荐</span>
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">phoneNumber</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">self</span><span class="o">.</span><span class="n">phoneNumber</span> <span class="o">=</span> <span class="n">phoneNumber</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div></div>

<div class="language-swift bad highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code><span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Person</span> <span class="p">{</span>
<span class="kd">public</span> <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="kd">public</span> <span class="k">let</span> <span class="nv">phoneNumber</span><span class="p">:</span> <span class="kt">String</span>
  
    <span class="c1">// 不推荐</span>
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">name</span> <span class="nv">otherName</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">phoneNumber</span> <span class="nv">otherPhoneNumber</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">otherName</span>
        <span class="n">phoneNumber</span> <span class="o">=</span> <span class="n">otherPhoneNumber</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div></div>

<h3 id="静态属性和类属性">静态属性和类属性</h3>

<p>静态属性和类属性返回声明类型的实例时，<strong>不需要</strong>加上该类型名字作后缀。</p>

<div class="language-swift good highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">UIColor</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="k">var</span> <span class="nv">red</span><span class="p">:</span> <span class="kt">UIColor</span> <span class="p">{</span>                <span class="c1">// 推荐</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
  
<span class="kd">public</span> <span class="kd">class</span> <span class="kt">URLSession</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="k">var</span> <span class="nv">shared</span><span class="p">:</span> <span class="kt">URLSession</span> <span class="p">{</span>          <span class="c1">// 推荐</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div></div>

<div class="language-swift bad highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">UIColor</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="k">var</span> <span class="nv">redColor</span><span class="p">:</span> <span class="kt">UIColor</span> <span class="p">{</span>           <span class="c1">// 不推荐</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
  
<span class="kd">public</span> <span class="kd">class</span> <span class="kt">URLSession</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="k">var</span> <span class="nv">sharedSession</span><span class="p">:</span> <span class="kt">URLSession</span> <span class="p">{</span>   <span class="c1">// 不推荐</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div></div>

<p>如果静态属性或者类属性用于描述该声明类型的单例实例，通常使用 <code class="language-plaintext highlighter-rouge">shared</code> 和 <code
                    class="language-plaintext highlighter-rouge">default</code> 作为名字。本指南不强制要求使用这些命名，作者可以自行选择对该类型有意义的名字。
                  </p>

            <h3 id="全局常量">全局常量</h3>

            <p>和其他变量类似，全局常量也使用 <code
                    class="language-plaintext highlighter-rouge">lowerCamelCase（驼峰命名法）</code>。不要使用匈牙利命名法，例如以 <code
                    class="language-plaintext highlighter-rouge">g</code> 或者 <code
                    class="language-plaintext highlighter-rouge">k</code> 开头。</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">let</span> <span class="nv">secondsPerMinute</span> <span class="o">=</span> <span class="mi">60</span>
  </code></pre>
                </div>
            </div>

<div class="language-swift bad highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code><span class="k">let</span> <span class="nv">SecondsPerMinute</span> <span class="o">=</span> <span class="mi">60</span>
<span class="k">let</span> <span class="nv">kSecondsPerMinute</span> <span class="o">=</span> <span class="mi">60</span>
<span class="k">let</span> <span class="nv">gSecondsPerMinute</span> <span class="o">=</span> <span class="mi">60</span>
<span class="k">let</span> <span class="nv">SECONDS_PER_MINUTE</span> <span class="o">=</span> <span class="mi">60</span>
</code></pre></div></div>

            <h3 id="代理方法">代理方法</h3>

            <p>受 Cocoa 框架里协议的命名启发，代理协议和类似代理的协议（例如数据源协议）里的方法命名，使用下面描述的口语化语法。</p>

            <blockquote>
                <p>术语“代理源对象”指的是响应代理方法的对象。例如：<code class="language-plaintext highlighter-rouge">UITableView</code> 是响应视图
                    <code class="language-plaintext highlighter-rouge">delegate</code> 属性设置的 <code
                        class="language-plaintext highlighter-rouge">UITableViewDeleagte</code> 里方法的源对象。
                </p>
            </blockquote>

            <p>所有方法将代理源对象作为第一个实参。</p>

            <p>对于<strong>只</strong>有代理源对象实参的方法：</p>

            <ul>
                <li>
                    <p>如果方法返回 <code
                            class="language-plaintext highlighter-rouge">void</code>（例如用于提醒代理事件发生），那么方法名为<strong>代理源类型</strong>后面加上描述事件的<strong>指示性动词</strong>。实参<strong>无标签</strong>。
                    </p>

                    <div class="language-swift good highlighter-rouge">
                        <div class="highlight">
                            <pre class="highlight"><code><span class="kd">func</span> <span class="nf">scrollViewDidBeginScrolling</span><span class="p">(</span><span class="n">_</span> <span class="nv">scrollView</span><span class="p">:</span> <span class="kt">UIScrollView</span><span class="p">)</span>
  </code></pre>
                        </div>
                    </div>
                </li>
                <li>
                    <p>如果方法返回 <code
                            class="language-plaintext highlighter-rouge">Bool</code>（例如对代理源对象本身做断言），那么方法名为<strong>代理源类型</strong>后面加上描述断言的<strong>指示性或条件性动词</strong>。实参<strong>无标签</strong>。
                    </p>

                    <div class="language-swift good highlighter-rouge">
                        <div class="highlight">
                            <pre class="highlight"><code><span class="kd">func</span> <span class="nf">scrollViewShouldScrollToTop</span><span class="p">(</span><span class="n">_</span> <span class="nv">scrollView</span><span class="p">:</span> <span class="kt">UIScrollView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
  </code></pre>
                        </div>
                    </div>
                </li>
                <li>
                    <p>如果方法返回其他值（例如查询代理源对象上的属性信息），那么方法名是描述查询属性的<strong>名词</strong>。实参<strong>标签是介词或后置介词</strong>，用于将名词和代理源对象合适地连接起来。
                    </p>

                    <div class="language-swift good highlighter-rouge">
                        <div class="highlight">
                            <pre class="highlight"><code><span class="kd">func</span> <span class="nf">numberOfSections</span><span class="p">(</span><span class="k">in</span> <span class="nv">scrollView</span><span class="p">:</span> <span class="kt">UIScrollView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
  </code></pre>
                        </div>
                    </div>
                </li>
            </ul>

            <p>对于在代理源对象后有<strong>额外</strong>实参的方法，方法名是代理源类型<strong>自身</strong>并且第一个实参<strong>无标签</strong>。然后：</p>

            <ul>
                <li>
                    <p>如果方法返回 <code
                            class="language-plaintext highlighter-rouge">void</code>，第二个实参<strong>标签是指示性动词</strong>，用于描述实参是<strong>直接宾语或者间接宾语</strong>的事件，并给其它实参（如果有的话）提供更多上下文。
                    </p>

                    <div class="language-swift good highlighter-rouge">
                        <div class="highlight">
                            <pre class="highlight"><code><span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span>
  <span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span>
    <span class="n">willDisplayCell</span> <span class="nv">cell</span><span class="p">:</span> <span class="kt">UITableViewCell</span><span class="p">,</span>
    <span class="n">forRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span>
  </code></pre>
                        </div>
                    </div>
                </li>
                <li>
                    <p>如果方法返回 <code
                            class="language-plaintext highlighter-rouge">Bool</code>，第二个实参<strong>标签是指示性或者条件性动词</strong>，用于描述对于实参的返回值，并给其他实参（如果有的话）提供更多上下文。
                    </p>

                    <div class="language-swift good highlighter-rouge">
                        <div class="highlight">
                            <pre class="highlight"><code><span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span>
  <span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span>
    <span class="n">shouldSpringLoadRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">,</span>
    <span class="n">with</span> <span class="nv">context</span><span class="p">:</span> <span class="kt">UISpringLoadedInteractionContext</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
  </code></pre>
                        </div>
                    </div>
                </li>
                <li>
                    <p>如果方法返回其他值，第二个实参<strong>标签是名词和后置介词</strong>，用于描述对于实参的返回值，并给其他实参（如果有的话）提供更多上下文。</p>

                    <div class="language-swift good highlighter-rouge">
                        <div class="highlight">
                            <pre class="highlight"><code><span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span>
  <span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span>
    <span class="n">heightForRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">CGFloat</span>
  </code></pre>
                        </div>
                    </div>
                </li>
            </ul>

            <p>Apple 的 <a
                    href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/DelegatesandDataSources/DelegatesandDataSources.html">代理和数据源</a>
                文档也提供了一些在这种情况下的通用命名指引。</p>

            <h2 id="编程实践">编程实践</h2>

            <p>本章节中规则的通用主旨是：避免冗余，避免歧义，除了能明显提高可读性和/或减少歧义外，尽量使用隐式而不是显式。</p>

            <h3 id="编译器警告">编译器警告</h3>

            <p>代码在编译时尽可能保持没有警告。在作者力所能及的范围内去除警告。</p>

            <p>如果不能马上迁移到替代 API，或者在 API 对外部用户废弃但还需要继续对库内部支持时，有理由的废弃警告可以保留。</p>

            <h3 id="构造器-1">构造器</h3>

            <p>对于 <code class="language-plaintext highlighter-rouge">Struct</code>，Swift 会合成实参为 <code
                    class="language-plaintext highlighter-rouge">var</code> 属性和缺少默认值的 <code
                    class="language-plaintext highlighter-rouge">let</code> 属性的非公开逐一成员 <code
                    class="language-plaintext highlighter-rouge">init</code>。如果该构造器已经足够（也就是说不需要 <code
                    class="language-plaintext highlighter-rouge">public</code>），直接使用，不需要写显式的构造器。</p>

            <p>永远不要直接调用遵循特殊 <code class="language-plaintext highlighter-rouge">ExpressibleBy*Literal</code> 编译器协议的构造器。
            </p>

<div class="language-swift good highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Kilometers</span><span class="p">:</span> <span class="kt">ExpressibleByIntegerLiteral</span> <span class="p">{</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">integerLiteral</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
  
<span class="k">let</span> <span class="nv">k1</span><span class="p">:</span> <span class="kt">Kilometers</span> <span class="o">=</span> <span class="mi">10</span>                          <span class="c1">// 推荐</span>
<span class="k">let</span> <span class="nv">k2</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">as</span> <span class="kt">Kilometers</span>                        <span class="c1">// 推荐</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Kilometers</span><span class="p">:</span> <span class="kt">ExpressibleByIntegerLiteral</span> <span class="p">{</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">integerLiteral</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
  
<span class="k">let</span> <span class="nv">k</span> <span class="o">=</span> <span class="kt">Kilometers</span><span class="p">(</span><span class="nv">integerLiteral</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>           <span class="c1">// 不推荐</span>
</code></pre></div></div>

<p>只有当调用者是元类型变量时才允许明确调用 <code
  class="language-plaintext highlighter-rouge">.init(...)</code>。使用字面量类型名字直接调用构造器时，省略 <code
  class="language-plaintext highlighter-rouge">.init</code>。（构造器使用 <code
  class="language-plaintext highlighter-rouge">MyType.init</code> 语法作为闭包进行<strong>引用</strong>是允许的。）
</p>

<div class="language-swift good highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code><span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="kt">MyType</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
  
<span class="k">let</span> <span class="nv">type</span> <span class="o">=</span> <span class="nf">lookupType</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="n">type</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
  
<span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="nf">makeValue</span><span class="p">(</span><span class="nv">factory</span><span class="p">:</span> <span class="kt">MyType</span><span class="o">.</span><span class="kd">init</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code><span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="kt">MyType</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="属性-1">属性</h3>

<p>只读计算属性的 <code class="language-plaintext highlighter-rouge">get</code> 块可以省略，将执行体直接嵌套在属性声明里。</p>

<div class="language-swift good highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code><span class="k">var</span> <span class="nv">totalCost</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">items</span><span class="o">.</span><span class="n">sum</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">cost</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div></div>

<div class="language-swift bad highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code><span class="k">var</span> <span class="nv">totalCost</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">items</span><span class="o">.</span><span class="n">sum</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">cost</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
  </code></pre></div></div>

            <h3 id="类型简称">类型简称</h3>

            <p>数组、字典和可选类型尽可能使用简写形式，也就是 <code class="language-plaintext highlighter-rouge">[Element]</code>，<code
                    class="language-plaintext highlighter-rouge">[Key: Value]</code> 和 <code
                    class="language-plaintext highlighter-rouge">Wrapped?</code>。完整形式 <code
                    class="language-plaintext highlighter-rouge">Array&lt;Element&gt;</code>，<code
                    class="language-plaintext highlighter-rouge">Dictionary&lt;Key, Value&gt;</code> 和 <code
                    class="language-plaintext highlighter-rouge">Optional&lt;Wrapped&gt;</code> 只有在编译器需要时才使用，例如 Swift
                语法分析程序不接受 <code class="language-plaintext highlighter-rouge">[Element].Index</code> 而需要用 <code
                    class="language-plaintext highlighter-rouge">Array&lt;Element&gt;.Index</code>。</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">func</span> <span class="n">enumeratedDictionary</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">from</span> <span class="nv">values</span><span class="p">:</span> <span class="p">[</span><span class="kt">Element</span><span class="p">],</span>
    <span class="nv">start</span><span class="p">:</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;.</span><span class="kt">Index</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">:</span> <span class="kt">Element</span><span class="p">]</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  </code></pre>
                </div>
            </div>

            <div class="language-swift bad highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">func</span> <span class="n">enumeratedDictionary</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">from</span> <span class="nv">values</span><span class="p">:</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="nv">start</span><span class="p">:</span> <span class="kt">Optional</span><span class="o">&lt;</span><span class="kt">Array</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;.</span><span class="kt">Index</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kc">nil</span>
  <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Dictionary</span><span class="o">&lt;</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Element</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  </code></pre>
                </div>
            </div>

<p><code class="language-plaintext highlighter-rouge">Void</code> 是空元组 <code
  class="language-plaintext highlighter-rouge">()</code> 的 <code
  class="language-plaintext highlighter-rouge">typealias</code>，所以从实现来说它们是等价的。在函数类型声明（例如闭包或者持有函数引用变量）的返回类型永远写作
    <code class="language-plaintext highlighter-rouge">void</code>，而不用 <code
  class="language-plaintext highlighter-rouge">()</code>。在用 <code
  class="language-plaintext highlighter-rouge">func</code> 关键字声明的函数中，全都省略 <code
  class="language-plaintext highlighter-rouge">void</code> 返回类型。
</p>

<p>空的实参列表永远写作 <code class="language-plaintext highlighter-rouge">()</code>，而不是 <code
  class="language-plaintext highlighter-rouge">Void</code>。（事实上，<code
  class="language-plaintext highlighter-rouge">Void -&gt; Result</code> 的函数签名在 Swift 里会报错，因为函数实参必须用括号包围，而 <code class="language-plaintext highlighter-rouge">(void)</code>有着其他含义：单个空元组实参的实参列表。）
</p>

<div class="language-swift good highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code><span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
  
<span class="k">let</span> <span class="nv">callback</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Void</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code><span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Void</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
  
<span class="kd">func</span> <span class="nf">doSomething2</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
  
<span class="k">let</span> <span class="nv">callback</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">()</span>
</code></pre></div></div>

            <h3 id="可选类型">可选类型</h3>

            <p>在设计算法时避免哨兵值（例如 <code class="language-plaintext highlighter-rouge">index</code> 是 -1
                表示集合里找不到某个元素）。哨兵值容易被偶然传递到其它逻辑层，因为类型系统没办法将它们和合法结果进行区分。</p>

            <p><code class="language-plaintext highlighter-rouge">Optional</code>
                用于传递一个非错误的结果，要不有值，要不没有值。例如：在集合中查询一个值时，值没有找到是一个<strong>合法并可预期</strong>的结果，而不是一个错误。</p>

<div class="language-swift good highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code><span class="kd">func</span> <span class="nf">index</span><span class="p">(</span><span class="n">of</span> <span class="nv">thing</span><span class="p">:</span> <span class="kt">Thing</span><span class="p">,</span> <span class="k">in</span> <span class="nv">things</span><span class="p">:</span> <span class="p">[</span><span class="kt">Thing</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">?</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
  
<span class="k">if</span> <span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="nf">index</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">thing</span><span class="p">,</span> <span class="nv">in</span><span class="p">:</span> <span class="n">lotsOfThings</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 找到了</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 没找到</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code><span class="kd">func</span> <span class="nf">index</span><span class="p">(</span><span class="n">of</span> <span class="nv">thing</span><span class="p">:</span> <span class="kt">Thing</span><span class="p">,</span> <span class="k">in</span> <span class="nv">things</span><span class="p">:</span> <span class="p">[</span><span class="kt">Thing</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
  
<span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="nf">index</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">thing</span><span class="p">,</span> <span class="nv">in</span><span class="p">:</span> <span class="n">lotsOfThings</span><span class="p">)</span>
<span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="c1">// 找到了</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 没找到</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Optional</code>
                也用于表示单一而明确失败的错误哨兵，也就是当操作是因为使用者明确的单个特定领域原因而失败时。（限制在特定领域，是为了排除那些用户明显无法正确处理的严重错误，例如内存不足错误。）</p>
<p>例如，如果字符串不能用适合类型位宽的合法整数表达，将字符串转换为整型可能会失败：</p>

<div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Int17</span> <span class="p">{</span>
    <span class="nf">init</span><span class="p">?(</span><span class="n">_</span> <span class="nv">string</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

            <p>如果要判断一个 <code class="language-plaintext highlighter-rouge">Optional</code> 非 <code
                    class="language-plaintext highlighter-rouge">nil</code> 但不需要访问解包值，可以直接和 <code
                    class="language-plaintext highlighter-rouge">nil</code> 进行比较。下面的例子能清晰地表达程序意图：</p>

<div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"value was not nil"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

            <p>这个例子里，用到了 Swift 模式匹配和绑定语法，将值解包后又马上丢弃，这就会让人产生误解（译者注：程序的目的是判断有没有值，但是这种写法看起来并不直观，好像有其他意图）。</p>

<div class="language-swift bad highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">if</span> <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">value</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"value was not nil"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="强制解包和强制类型转换">强制解包和强制类型转换</h3>

            <p>强制解包和强制类型转换通常说明代码有问题，强烈不推荐。除非它能通过周围代码解释清楚该操作的安全性，并需要附加注释来描述这个操作是永远安全的。例如，</p>

<div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="nf">getSomeInteger</span><span class="p">()</span>
  
  <span class="c1">// ...无关代码...</span>
  
  <span class="c1">// 这里的强制解包是安全的，会保证传入的 `value` 是合法的，因为它的数据源只提供这些合法枚举项</span>
<span class="k">return</span> <span class="kt">SomeEnum</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span><span class="o">!</span>
</code></pre></div></div>

            <blockquote>
                <p><strong>例外：</strong>在单元测试和仅用于测试的代码里，允许使用没有注释的强制解包。这可以减少代码中不必要的控制流。在 <code
                        class="language-plaintext highlighter-rouge">nil</code> 被解包或者不合适的类型擦除发生时，测试也会按照预期而失败。</p>
            </blockquote>

            <h3 id="可选值隐式解包">可选值隐式解包</h3>

            <p>可选值隐式解包本身是不安全的，尽可能使用非可选值声明，或者使用常规的 <code class="language-plaintext highlighter-rouge">Optional</code>
                类型。下面是一些特殊情况。</p>

            <p>存活时间基于 UI 生命周期而不是严格基于持有关系的用户界面元素，可以使用可选值显式解包。这种情况的例子包括连接 XIB 文件或 storyboard 中元素的 <code
                    class="language-plaintext highlighter-rouge">@IBOutlet</code> 属性，外部初始化的属性（例如 view controller 调用的
                <code class="language-plaintext highlighter-rouge">prepareForSegue</code> 实现），还有在类生命周期中初始化的属性（例如在 view
                controller <code class="language-plaintext highlighter-rouge">viewDidLoad</code>
                方法里初始化的视图）。这些属性如果用可选值，会加重使用者解包的负担，因为它们能确保非空，并且一旦初始化完毕就会一直有值。
            </p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">class</span> <span class="kt">SomeViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    <span class="kd">@IBOutlet</span> <span class="k">var</span> <span class="nv">button</span><span class="p">:</span> <span class="kt">UIButton</span><span class="o">!</span>
  
    <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
      <span class="nf">populateLabel</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">button</span><span class="p">)</span>
    <span class="p">}</span>
  
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">populateLabel</span><span class="p">(</span><span class="k">for</span> <span class="nv">button</span><span class="p">:</span> <span class="kt">UIButton</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
  </code></pre></div></div>

            <h3 id="访问等级">访问等级</h3>

            <p><strong>除 internal 外，其它访问等级在声明里不允许省略(比如：外面不使用的声明必须显示添加 private)</strong>。顶层声明的默认访问等级是 <code
                    class="language-plaintext highlighter-rouge">internal</code>。嵌套的声明默认访问等级和其外层声明访问等级相同，但不能高于 <code
                    class="language-plaintext highlighter-rouge">internal</code> 。</p>

            <p>给文件级别的扩展指定显式访问等级是不允许的。拓展里的每一个成员如果不采用默认的访问等级，则应该单独进行指定。</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">extension</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">isUppercase</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
  
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">isLowercase</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

            <div class="language-swift bad highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">public</span> <span class="kd">extension</span> <span class="kt">String</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">isUppercase</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
  
    <span class="k">var</span> <span class="nv">isLowercase</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

            <h3 id="嵌套和命名空间">嵌套和命名空间</h3>

            <p>Swift 里允许嵌套 <code class="language-plaintext highlighter-rouge">enum</code>、<code
                    class="language-plaintext highlighter-rouge">struct</code> 和 <code
                    class="language-plaintext highlighter-rouge">class</code>，嵌套更适合（比起命名约定）表示作用域和类型之间的分级关系，因此推荐使用。例如，把类型相关的
                <code class="language-plaintext highlighter-rouge">enum</code> 或者错误类型放到这个类型内部。
            </p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">class</span> <span class="kt">Parser</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">Error</span><span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Error</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nf">invalidToken</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
        <span class="k">case</span> <span class="n">unexpectedEOF</span>
    <span class="p">}</span>
  
    <span class="kd">func</span> <span class="nf">parse</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

            <div class="language-swift bad highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">class</span> <span class="kt">Parser</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">parse</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
  
<span class="kd">enum</span> <span class="kt">ParseError</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">invalidToken</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">unexpectedEOF</span>
<span class="p">}</span></code></pre></div></div>

            <p>Swift 目前还不支持在其它类型中嵌套协议，反之亦然，所以该规则不适用于某些情况，例如控制器类型和它的代理协议。</p>

            <p>如果要定一个“命名空间”来对互相关联的声明（例如常量或者帮助方法）就行分组，公认的做法是声明一个没有枚举项的 <code
                    class="language-plaintext highlighter-rouge">enum</code>。该 <code
                    class="language-plaintext highlighter-rouge">enum</code> 自然不存在实例，并且不需要额外的样板代码来避免被实例化。</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Dimensions</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">tileMargin</span><span class="p">:</span> <span class="kt">CGFloat</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">tilePadding</span><span class="p">:</span> <span class="kt">CGFloat</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">tileContentSize</span><span class="p">:</span> <span class="kt">CGSize</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">64</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

            <div class="language-swift bad highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Dimensions</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{}</span>
  
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">tileMargin</span><span class="p">:</span> <span class="kt">CGFloat</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">tilePadding</span><span class="p">:</span> <span class="kt">CGFloat</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">tileContentSize</span><span class="p">:</span> <span class="kt">CGSize</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">64</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

            <h3 id="提前退出的-guard">提前退出的 <code class="language-plaintext highlighter-rouge">guard</code></h3>

            <p><code class="language-plaintext highlighter-rouge">guard</code> 语句，比起条件相反的 <code
                    class="language-plaintext highlighter-rouge">if</code> 语句，会更好地从视觉上强调，该检查条件会导致从当前作用域提前退出。</p>

            <p>更远了说，<code class="language-plaintext highlighter-rouge">guard</code>
                语句通过减少额外嵌套层级（“鞭尸金字塔”）来提高可读性；令错误情况和触发条件靠近，而主逻辑在作用域里保持向左对齐。</p>

            <p>下面的例子中会体现这些理论；第一种例子里，有清晰的流程，检查不合法的状态并退出，然后在成功的情况下执行主逻辑。在没有 <code
                    class="language-plaintext highlighter-rouge">guard</code>
                的第二个例子里，主逻辑混杂在某个任意嵌套层级里，抛出的错误和它们的触发条件被分隔得很开。</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">func</span> <span class="nf">discombobulate</span><span class="p">(</span><span class="n">_</span> <span class="nv">values</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">first</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">first</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="kt">DiscombobulationError</span><span class="o">.</span><span class="n">arrayWasEmpty</span>
    <span class="p">}</span>
    <span class="k">guard</span> <span class="n">first</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="kt">DiscombobulationError</span><span class="o">.</span><span class="n">negativeEnergy</span>
    <span class="p">}</span>
  
    <span class="k">var</span> <span class="nv">result</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="n">values</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="nf">invertedCombobulatoryFactory</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
  </code></pre>
                </div>
            </div>

            <div class="language-swift bad highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="kd">func</span> <span class="nf">discombobulate</span><span class="p">(</span><span class="n">_</span> <span class="nv">values</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">first</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">first</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">first</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">var</span> <span class="nv">result</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="n">values</span> <span class="p">{</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="nf">invertedCombobulatoryFactor</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="k">throw</span> <span class="kt">DiscombobulationError</span><span class="o">.</span><span class="n">negativeEnergy</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="kt">DiscombobulationError</span><span class="o">.</span><span class="n">arrayWasEmpty</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div></div>

            <p>在循环语句中，<code class="language-plaintext highlighter-rouge">guard</code>-<code
                    class="language-plaintext highlighter-rouge">continue</code> 语句也可以避免增加缩进，比如整个循环体只在某些情况下执行（不过要结合下面的
                <code class="language-plaintext highlighter-rouge">for</code>-<code
                    class="language-plaintext highlighter-rouge">where</code> 规范）。
            </p>


            <h3 id="在-switch-语句里的-fallthrough">在 <code class="language-plaintext highlighter-rouge">switch</code> 语句里的
                <code class="language-plaintext highlighter-rouge">fallthrough</code>
            </h3>

            <p>当 <code class="language-plaintext highlighter-rouge">switch</code> 里的多个 <code
                    class="language-plaintext highlighter-rouge">case</code> 执行同样的语句时，这些 <code
                    class="language-plaintext highlighter-rouge">case</code> 可以合并成一个范围或者逗号分隔的列表。声明多个 <code
                    class="language-plaintext highlighter-rouge">case</code> 却不做任何事，只是 <code
                    class="language-plaintext highlighter-rouge">fallthrough</code> 到后面的 <code
                    class="language-plaintext highlighter-rouge">case</code> 是不允许的。</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">switch</span> <span class="n">value</span> <span class="p">{</span>
<span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="s">"one"</span><span class="p">)</span>
<span class="k">case</span> <span class="mi">2</span><span class="o">...</span><span class="mi">4</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="s">"two to four"</span><span class="p">)</span>
<span class="k">case</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="s">"five or seven"</span><span class="p">)</span>
<span class="k">default</span><span class="p">:</span> <span class="k">break</span>
<span class="p">}</span>
</code></pre></div></div>

            <div class="language-swift bad highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">switch</span> <span class="n">value</span> <span class="p">{</span><span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="s">"one"</span><span class="p">)</span>
<span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="k">fallthrough</span>
<span class="k">case</span> <span class="mi">3</span><span class="p">:</span> <span class="k">fallthrough</span>
<span class="k">case</span> <span class="mi">4</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="s">"two to four"</span><span class="p">)</span>
<span class="k">case</span> <span class="mi">5</span><span class="p">:</span> <span class="k">fallthrough</span>
<span class="k">case</span> <span class="mi">7</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="s">"five or seven"</span><span class="p">)</span>
<span class="k">default</span><span class="p">:</span> <span class="k">break</span>
<span class="p">}</span>
</code></pre></div></div>

            <h3 id="数字和字符串字面量">数字和字符串字面量</h3>

            <p>Swift 里的整型和字符串字面量没有固定类型。例如，<code class="language-plaintext highlighter-rouge">5</code> 本身不是一个 <code
                    class="language-plaintext highlighter-rouge">Int</code>；它能表示遵循 <code
                    class="language-plaintext highlighter-rouge">ExpressibleByIntegerLiteral</code>
                的任何类型，只有类型推断无法找到更明确的类型时，才会变成 <code class="language-plaintext highlighter-rouge">Int</code>。类似的，字面量 <code
                    class="language-plaintext highlighter-rouge">"x"</code> 并不是 <code
                    class="language-plaintext highlighter-rouge">String</code>、<code
                    class="language-plaintext highlighter-rouge">Character</code> 或 <code
                    class="language-plaintext highlighter-rouge">UnicodeScalar</code>，不过它可以根据上下文变成这些类型，默认情况是变成 <code
                    class="language-plaintext highlighter-rouge">String</code>。</p>

            <p>因此类型在使用默认以外的字面量方式构造值，并且该类型不能通过上下文推断更多信息时，需要在声明里用显式类型，或者用 <code
                    class="language-plaintext highlighter-rouge">as</code> 表达式来进行强制转换。</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="c1">// 没有更明确的类型，x1 会被推断为 Int 类型。</span>
  <span class="k">let</span> <span class="nv">x1</span> <span class="o">=</span> <span class="mi">50</span>
  
  <span class="c1">// 这些是明确的 Int32 类型。</span>
  <span class="k">let</span> <span class="nv">x2</span><span class="p">:</span> <span class="kt">Int32</span> <span class="o">=</span> <span class="mi">50</span>
  <span class="k">let</span> <span class="nv">x3</span> <span class="o">=</span> <span class="mi">50</span> <span class="k">as</span> <span class="kt">Int32</span>
  
  <span class="c1">// 没有更明确的类型，y1 会被推断为 String 类型。</span>
  <span class="k">let</span> <span class="nv">y1</span> <span class="o">=</span> <span class="s">"a"</span>
  
  <span class="c1">// 这些是明确的 Character 类型。</span>
  <span class="k">let</span> <span class="nv">y2</span><span class="p">:</span> <span class="kt">Character</span> <span class="o">=</span> <span class="s">"a"</span>
  <span class="k">let</span> <span class="nv">y3</span> <span class="o">=</span> <span class="s">"a"</span> <span class="k">as</span> <span class="kt">Character</span>
  
  <span class="c1">// 这些是明确的 UnicodeScalar 类型。</span>
  <span class="k">let</span> <span class="nv">y4</span><span class="p">:</span> <span class="kt">UnicodeScalar</span> <span class="o">=</span> <span class="s">"a"</span>
  <span class="k">let</span> <span class="nv">y5</span> <span class="o">=</span> <span class="s">"a"</span> <span class="k">as</span> <span class="kt">UnicodeScalar</span>
  
  <span class="kd">func</span> <span class="nf">writeByte</span><span class="p">(</span><span class="n">_</span> <span class="nv">byte</span><span class="p">:</span> <span class="kt">UInt8</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  
  <span class="c1">// 函数实参也可以推断，所以 50 是 UInt 但不需要强制明确。</span>
  <span class="nf">writeByte</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
  </code></pre>
                </div>
            </div>

            <p>如果字面量的强制转换不合理，编译器会抛出对应的错误，例如，将不是整数的数字转换成整数，或者将一个字符串转换成字符。所以下面例子抛出错误是“好”事，因为这些错误在编译期就找到了正确的原因。</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="c1">// 错误：整型字面量 ‘9223372036854775808’ 存储为 ‘Int64’ 里会溢出</span>
  <span class="k">let</span> <span class="nv">a</span> <span class="o">=</span> <span class="mh">0x8000_0000_0000_0000</span> <span class="k">as</span> <span class="kt">Int64</span>
  
  <span class="c1">// 错误：无法将“String”类型的值强制转换为“Character”</span>
  <span class="k">let</span> <span class="nv">b</span> <span class="o">=</span> <span class="s">"ab"</span> <span class="k">as</span> <span class="kt">Character</span>
  </code></pre>
                </div>
            </div>

            <p>如果使用构造器语法对这些类型进行强制转换，会产生易误导的编译器错误，也可能更糟，产生难调试的运行时错误。</p>

            <div class="language-swift bad highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="c1">// 这里首先尝试通过字面量创建一个 `Int`(有符号的)，然后转换为 `UInt64`。尽管这个字面量能存入 `UInt64`，</span>
  <span class="c1">// 但它在第一步无法存入 `Int`，所以这里无法通过编译。</span>
  <span class="k">let</span> <span class="nv">a1</span> <span class="o">=</span> <span class="kt">UInt64</span><span class="p">(</span><span class="mh">0x8000_0000_0000_0000</span><span class="p">)</span>
  
  <span class="c1">// 这里调用 `Character.init(_: String)`，因此会在运行时创建一个 `String` 的“a”（会涉及到耗时的堆分配），</span>
  <span class="c1">// 从中提取字符，然后再释放掉它。这比恰当的强制指定耗时明显。</span>
  <span class="k">let</span> <span class="nv">b</span> <span class="o">=</span> <span class="kt">Character</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span>
  
  <span class="c1">// 和上面类似，这里会创建一个 `String` 并且使用 `Character.init(_: String)` 尝试从中提取单个字符。</span>
  <span class="c1">// 这会因此先决条件在运行时发生错误。</span>
  <span class="k">let</span> <span class="nv">c</span> <span class="o">=</span> <span class="kt">Character</span><span class="p">(</span><span class="s">"ab"</span><span class="p">)</span>
  </code></pre>
                </div>
            </div>

            <h3 id="playground-字面量">Playground 字面量</h3>

            <p>禁止在非 playground 的代码中使用会进行图形渲染的 playground 字面量：<code
                    class="language-plaintext highlighter-rouge">#colorLiteral(...)</code>、<code
                    class="language-plaintext highlighter-rouge">#imageLiteral(...)</code> 和 <code
                    class="language-plaintext highlighter-rouge">#fileLiteral(...)</code>。它们只允许出现在 playground 源码里。</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">let</span> <span class="nv">color</span> <span class="o">=</span> <span class="kt">UIColor</span><span class="p">(</span><span class="nv">red</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">green</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">blue</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">alpha</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
  </code></pre>
                </div>
            </div>

            <div class="language-swift bad highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="k">let</span> <span class="nv">color</span> <span class="o">=</span> <span class="err">#</span><span class="nf">colorLiteral</span><span class="p">(</span><span class="nv">red</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">green</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">blue</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">alpha</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
  </code></pre>
                </div>
            </div>

            <h3 id="定义新运算符">定义新运算符</h3>

            <p>不理智地使用自定义运算符会显著影响代码可读性，因为比起标准库中更常用的运算符，这样的运算符缺乏共识，不容易被理解。</p>

            <p>通常来说，应该避免定义自定义运算符。然而，当一个运算符在问题领域中有清晰和含义良好的定义，并且使用它会比函数调用显著提高代码的可读性时，可以使用。例如，<code
                    class="language-plaintext highlighter-rouge">*</code> 在 Swift
                里只定义为乘法运算符（不包含掩码版本）。数学矩阵库可能会定义额外的运算符来支持其他运算比如叉乘和点乘。</p>

            <p>自定义 <code class="language-plaintext highlighter-rouge">&lt;~~</code> 和 <code
                    class="language-plaintext highlighter-rouge">~~&gt;</code> 运算符来解码和编码 JSON 数据就是典型的禁止用法。这样的运算符不是 JSON
                领域问题的原生处理方式，哪怕是有经验的 Swift 工程师，在没有运算符文档的情况下也可能会对这种处理代码有着不同的理解。</p>

            <p>如果你必须使用第三方代码里的自定义运算符，那<strong>强烈建议</strong>你编写一个包装器，定义可读性更好的方法，作为该自定义运算符的代理。对团队新成员或者其他代码审查者来说，这会显著降低学习曲线，更快的理解代码原理。
            </p>

            <h3 id="重载现有运算符">重载现有运算符</h3>

            <p>原则上禁止重载现有运算符</p>

            <h2 id="文档注释">文档注释</h2>

            <h3 id="通常格式">通常格式</h3>

            <p>文档注释使用每行前面三个斜杠（<code class="language-plaintext highlighter-rouge">///</code>）的格式。Java 文档风格的块状注释（<code
                    class="language-plaintext highlighter-rouge">/** ...*/</code>）是不允许的。</p>

<div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="c1">/// Returns the numeric value of the given digit represented as a Unicode scalar.</span>
<span class="c1">///</span>
<span class="c1">/// - Parameters:</span>
<span class="c1">///   - digit: The Unicode scalar whose numeric value should be returned.</span>
<span class="c1">///   - radix: The radix, between 2 and 36, used to compute the numeric value.</span>
<span class="c1">/// - Returns: The numeric value of the scalar.</span>
<span class="kd">func</span> <span class="nf">numericValue</span><span class="p">(</span><span class="n">of</span> <span class="nv">digit</span><span class="p">:</span> <span class="kt">UnicodeScalar</span><span class="p">,</span> <span class="nv">radix</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

            <div class="language-swift bad highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="cm">/**
   * Returns the numeric value of the given digit represented as a Unicode scalar.
   *
   * - Parameters:
   *   - digit: The Unicode scalar whose numeric value should be returned.
   *   - radix: The radix, between 2 and 36, used to compute the numeric value.
   * - Returns: The numeric value of the scalar.
   */</span>
  <span class="kd">func</span> <span class="nf">numericValue</span><span class="p">(</span><span class="n">of</span> <span class="nv">digit</span><span class="p">:</span> <span class="kt">UnicodeScalar</span><span class="p">,</span> <span class="nv">radix</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
      <span class="c1">// ...</span>
  <span class="p">}</span>
  
  <span class="cm">/**
  Returns the numeric value of the given digit represented as a Unicode scalar.
  
  - Parameters:
    - digit: The Unicode scalar whose numeric value should be returned.
    - radix: The radix, between 2 and 36, used to compute the numeric value.
  - Returns: The numeric value of the scalar.
  */</span>
  <span class="kd">func</span> <span class="nf">numericValue</span><span class="p">(</span><span class="n">of</span> <span class="nv">digit</span><span class="p">:</span> <span class="kt">UnicodeScalar</span><span class="p">,</span> <span class="nv">radix</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
      <span class="c1">// ...</span>
  <span class="p">}</span>
  </code></pre>
                </div>
            </div>

            <h3 id="一句话概括">一句话概括</h3>

            <p>文档注释的开始使用简短的<strong>一句话</strong>概括来描述声明。（这句话可以跨行，但如果跨了很多行，作者应该考虑是否可以将概况简化，并将细节移到新的段落中。）</p>

            <p>如果概括需要陈述更多细节，在后面添加额外的段落（每个段落用空行分隔）。</p>

            <p>一句话概括不需要是完整的句子；例如，方法的概括通常写作动词短语，<strong>不需要</strong>加上“这个方法
                […]”，因为这就是要表达的，写出来是多余的。类似，属性通常写作名词短语，<strong>不需要</strong>加上“这个属性是 […]”。然而无论如何，它们还是要以句号结尾。</p>

            <div class="language-swift good highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="c1">/// The background color of the view.</span>
  <span class="k">var</span> <span class="nv">backgroundColor</span><span class="p">:</span> <span class="kt">UIColor</span>
  
  <span class="c1">/// Returns the sum of the numbers in the given array.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Parameter numbers: The numbers to sum.</span>
  <span class="c1">/// - Returns: The sum of the numbers.</span>
  <span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
      <span class="c1">// ...</span>
  <span class="p">}</span>
  </code></pre>
                </div>
            </div>

            <div class="language-swift bad highlighter-rouge">
                <div class="highlight">
                    <pre class="highlight"><code><span class="c1">/// This property is the background color of the view.</span>
  <span class="k">var</span> <span class="nv">backgroundColor</span><span class="p">:</span> <span class="kt">UIColor</span>
  
  <span class="c1">/// This method returns the sum of the numbers in the given array.</span>
  <span class="c1">///</span>
  <span class="c1">/// - Parameter numbers: The numbers to sum.</span>
  <span class="c1">/// - Returns: The sum of the numbers.</span>
  <span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
      <span class="c1">// ...</span>
  <span class="p">}</span>
  </code></pre>
                </div>
            </div>

            <h3 id="形参返回值和抛出标签">形参，返回值和抛出标签</h3>

            <p>Xcode 里编写文档注释的推荐方式是将文字光标放在声明上并且按下 <strong>Command + Option + /</strong>。这会自动创建有待填充占位符的正确格式注释。</p>

            <p><code class="language-plaintext highlighter-rouge">Parameter(s)</code>、<code
                    class="language-plaintext highlighter-rouge">Returns</code> 和 <code
                    class="language-plaintext highlighter-rouge">Throws</code> 标签后面跟着的内容需要以句号结尾，即使它们只是短语而不是完整的句子。</p>

            <h3 id="apple-标记格式">Apple 标记格式</h3>

            <p>强烈建议使用 <a
                    href="https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/">Apple
                    标记格式</a> 来添加富文本到文档中。这种标记有助于区分注释里的特征引用（例如形参名字）和描述性文本，并且可以被 Xcode 和其他文档生成工具渲染。下面列出一些常用指令的示例。</p>

            <ul>
                <li>段落以 <code class="language-plaintext highlighter-rouge">///</code> 开始的单一空白行分隔。</li>
                <li>以<em>*单星号*</em>和<em>_单下划线_</em>包围的文本会被渲染成斜体/斜型。</li>
                <li>以<strong>**双星号**</strong>和<strong>__双下划线__</strong>包围的文本会被渲染成粗体。</li>
                <li>符号名或者内联代码以 <code class="language-plaintext highlighter-rouge">`反引号`</code>包围。</li>
                <li>多行代码（例如作为用例）以三个反引号（<code class="language-plaintext highlighter-rouge"> </code>`` `）的行开头和结束。</li>
            </ul>

            <h3 id="注释的位置">注释的位置</h3>

            <p>最起码，每个 open 或 public 声明和里面的每个 open 或 public 成员都应该有文档注释，除了下面的情况：</p>

            <ul>
                <li>
                    <p><code class="language-plaintext highlighter-rouge">enum</code>
                        里单个的枚举项名字如果已经可以自解释，则通常不需要注释。有关联值的枚举项如果值的含义不明确，那么不管怎样都应该注释。</p>
                </li>
                <li>
                    <p>覆盖父类的声明、协议要求的实现或者提供协议要求的默认实现的扩展声明。</p>

                    <p>覆盖声明可以添加注释来描述新行为。但是任何情况下都不应该单纯拷贝基类的声明文档。</p>
                </li>
                <li>
                    <p>测试类和测试方法可以不需要文档注释。然而，注释对于在多个测试里复用的函数式测试类和帮助类/方法时是有帮助的。</p>
                </li>
                <li>
                    <p>扩展声明（也就是自身的 <code
                            class="language-plaintext highlighter-rouge">extension</code>）可以不需要文档注释。如果能帮助明确拓展的用途，你可以选择添加，但避免无意义或者误导的注释。
                    </p>

                    <p>在下面的例子中，注释仅仅重复了源码显而易见的事：</p>

                    <div class="language-swift bad highlighter-rouge">
                        <div class="highlight">
                            <pre class="highlight"><code><span class="c1">/// Add `Equatable` conformance.</span>
  <span class="kd">extension</span> <span class="kt">MyType</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  </code></pre>
                        </div>
                    </div>

                    <p>下面的例子更微妙一些，但这是一个注释无法拓展的例子，因为这个拓展或者类型一致性在以后可能会变化。这个 <code
                            class="language-plaintext highlighter-rouge">Comparable</code>
                        可能是在编写对该类型值的排序代码时加上的，但这不是一致性的唯一可能用途，并且使用者可能在以后其他用途代码里会依赖它。</p>

                    <div class="language-swift bad highlighter-rouge">
                        <div class="highlight">
                            <pre class="highlight"><code><span class="c1">/// Make `Candidate` comparable so that they can be sorted.</span>
  <span class="kd">extension</span> <span class="kt">Candidate</span><span class="p">:</span> <span class="kt">Comparable</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  </code></pre>
                        </div>
                    </div>
                </li>
            </ul>

            <p>通常来说，如果你发现你写的注释只是简单地重复源码中显而易见的事，并用类似”用于表示”的词语进行美化，那么将这些注释完全去掉。</p>

            <p>但是，<em>不</em>要用这个例外来证明可以省略某些正常读者可能需要的相关信息。例如，对于 <code
                    class="language-plaintext highlighter-rouge">canonicalName</code> 名字的属性，不要省略注释（只有合理的时候才可以只写 <code
                    class="language-plaintext highlighter-rouge">/// The canonical name.</code>），因为正常读者可能不知道术语“规范名字”在上下文中的含义。
                使用注释是定义该术语的好机会。</p>

        </article>

    </main>

</body>

</html>